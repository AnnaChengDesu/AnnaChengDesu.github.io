<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Design Pattern on Anna.me</title>
    <link>https://annachengdesu.github.io/categories/design-pattern/</link>
    <description>Recent content in Design Pattern on Anna.me</description>
    <image>
      <title>Anna.me</title>
      <url>https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://annachengdesu.github.io/categories/design-pattern/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01-Command Pattern-设计模式学习-vanilla篇</title>
      <link>https://annachengdesu.github.io/post/patterns/command-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://annachengdesu.github.io/post/patterns/command-pattern/</guid>
      <description>Command Pattern 命令模式 使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。
假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。
class OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =&amp;gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。
但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。
假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。</description>
    </item>
    
    <item>
      <title>02-Factory Pattern-设计模式学习-vanilla篇</title>
      <link>https://annachengdesu.github.io/post/patterns/factory-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://annachengdesu.github.io/post/patterns/factory-pattern/</guid>
      <description>Factory Pattern 工厂模式 通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。
假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。
const createUser = ({ firstName, lastName, email }) =&amp;gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。
const user1 = createUser({ firstName: &amp;#34;Anna&amp;#34;, lastName: &amp;#34;Cheng&amp;#34;, email: &amp;#34;AnnaCheng@gmail.com&amp;#34; }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。
const createObjectFromArray = ([key, value]) =&amp;gt; ({ [key]: value, }); createObjectFromArray([&amp;#34;name&amp;#34;, &amp;#34;John&amp;#34;]); // { name: &amp;#34;John&amp;#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。</description>
    </item>
    
    <item>
      <title>03-Mediator/Middleware Pattern-设计模式学习-vanilla篇</title>
      <link>https://annachengdesu.github.io/post/patterns/mediator-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://annachengdesu.github.io/post/patterns/mediator-pattern/</guid>
      <description>Mediator/Middleware Pattern 中介者/中间件模式 中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。
可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。
在Javascript中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。
对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。
调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。
class ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。
const chatroom = new ChatRoom(); const user1 = new User(&amp;#34;John Doe&amp;#34;, chatroom); const user2 = new User(&amp;#34;Jane Doe&amp;#34;, chatroom); user1.</description>
    </item>
    
  </channel>
</rss>
