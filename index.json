[{"content":"问题现象 ​ 本文以 Windows 系统为例进行说明。\n​ 在更换网络环境后，在个人电脑上使用 git push 命令推动代码至 Github 报错。\nssh: connect to host github.com port 22: Connection refused\rfatal: Could not read from remote repository.\rPlease make sure you have the correct access rights\rand the repository exists. 排查过程 ​ 报错提示的是连接 github.com 的 22 端口被拒绝了。遂使用浏览器访问 github.com，确实无法访问，开梯子后网页访问正常，但 git push 依旧失败。\n使用 Github 的 443 端口 ​ 网上搜索后发现可能是 22 端口被防火墙屏蔽了，可以尝试连接 Github 的 443 端口。\n​ 命令 ssh -T git@github.com 可以检测和 Github 的网络通信是否正常，执行后报错 连接超时。\n​ 接着执行命令 ssh -T -p 443 git@ssh.github.com 测试 443 端口能否通信，提示 \u0026ldquo;Hi xxxxx! You\u0026rsquo;ve successfully authenticated, but GitHub does notprovide shell access\u0026rdquo;，则表示连接正常。\n​ 那就可以在 ~/.ssh/config 文件中配置以下内容，这样 ssh 在连接 Github 的时候就会使用 443 端口。如果~/.ssh目录下没有 config 文件，新建一个即可。（如果新建 config 后执行 git 操作报错 Bad owner or permissions on xxx/.ssh/config，可见下文解决思路）\nHost github.com\rHostname ssh.github.com\rPort 443 ​ 至此完成以上操作后 git 的 ssh 连接恢复正常。另外网络上还有其他解决方案，没有尝试过但先列举在这里，以后说不定会用上。\n将使用 ssh 协议更改为 https 协议 在 GitHub 的本地 repo 目录，执行如下命令：\n$ git config --local -e 然后把里面的 url 配置项从 git 格式\nurl = git@github.com:username/repo.git 修改为 https 格式\nurl = https://github.com/username/repo.git 这个其实修改的是 repo 根目录下的.git/config文件。\n新建 .ssh/config 文件执行 git 操作报错 Bad owner or permissions on xxx/.ssh/config ​ 这个错误的原因是：文件夹.ssh 的权限不仅仅是 windows 当前用户拥有或者当前用户权限不足，故修改权限即可。\n解决方法：\n找到 .ssh 文件夹，它通常位于 C:\\Users。 右键单击 .ssh 文件夹，单击“属性”，再点击安全标签。 单击 高级 \u0026gt; 禁用继承，单击确定。 会出现警告弹出窗口，点击从此对象中删除所有继承的权限。 你能看到所有用户都将被删除。让我们添加所有者。在同一窗口中，单击编辑按钮。 单击添加以显示选择用户或组窗口。 单击高级，然后单击“立即查找”按钮。应显示用户结果列表。 选择您的用户帐户。 然后单击确定（大约三次）以关闭所有窗口。 完成所有操作后， 尝试连接到远程 SSH 主机，这个问题应该解决了。 ","permalink":"https://annachengdesu.github.io/post/problem-solved/github-ssh-connection-refuse/","summary":"问题现象 ​ 本文以 Windows 系统为例进行说明。\n​ 在更换网络环境后，在个人电脑上使用 git push 命令推动代码至 Github 报错。\nssh: connect to host github.com port 22: Connection refused\rfatal: Could not read from remote repository.\rPlease make sure you have the correct access rights\rand the repository exists. 排查过程 ​ 报错提示的是连接 github.com 的 22 端口被拒绝了。遂使用浏览器访问 github.com，确实无法访问，开梯子后网页访问正常，但 git push 依旧失败。\n使用 Github 的 443 端口 ​ 网上搜索后发现可能是 22 端口被防火墙屏蔽了，可以尝试连接 Github 的 443 端口。\n​ 命令 ssh -T git@github.com 可以检测和 Github 的网络通信是否正常，执行后报错 连接超时。","title":"Github报错：ssh: connect to host github.com port 22: Connection refused"},{"content":"问题描述：\n前端仓库的 CI Runner 并行处理两个 job 有概率出现报错内容缺失或出包内容错误。\n问题分析：\n​ Gitlab 官方称：当只有一个 runner 在运行并且每个[[runner]] section 都有独立的 build 路径，concurrent 是生效的。若有多个 runner 使用同个 config.toml 文件或共享同个 build 路径，即使设置了 concurrent 为 1，也还是会有概率出现一个 runner 并发处理多个 job 的问题，官方认为这是用户的错误配置。config.toml 文件允许存在多个[[runner]] section，但这个 bug 会导致 concurrent 失效。\n​ 根据上次 ci runner 出现打包内容错误的问题推测是当时 config.toml 配置上的失误，即多个 runner 使用同个 config.toml 文件并且没有指定 build_dir（默认对应于宿主机的目录是在宿主机 的 docker volume )，因此有概率出现一个 runner 同时处理两个 job 的情况(curcurrent 设置为 1)，再加上一个 runner 映射一个 volume，从 gitlab 上拉下的源代码都存储在同个 volume，后拉的替换先拉的，最终导致必有一个 job 打出的包有问题含有其他分支的内容或直接报错编译失败。\n​ Branch_3.5.3 出的 sp4 包内容含其他分支的内容也就同样能解释通了，从下图中可以看出两次 job 先后执行并且持续了一段时间，但使用的是同一台 runner、同一个 volume，由于 Branch_3.5.3 的 job(后文称 job1)率先执行，所以 volume 内存储了 Branch_3.5.3 分支的源代码，5 分钟后，Branch_cmcc_sdwan 的 job(后文称 job2)开始执行并且此时 job1 还未结束，runner checkout 到了 job2 的分支并将 job2 的源代码存储到了相同的 volume，即 job1 的源代码被 job2 替换了。不幸的是此次编译过程没有报错，打包成功了，最终导致在无感知的情况下给出了错误的包。\n解决方案：\n一个 runner 独立使用一个 config.toml 文件，这样 config.toml 文件中的 concurrent = 1 配置就会生效，也就规避了 concurrent 配置失效导致一个 runner 同时处理多个 job 触发的 bug。\n","permalink":"https://annachengdesu.github.io/post/problem-solved/gitlab-ci-cd/","summary":"问题描述：\n前端仓库的 CI Runner 并行处理两个 job 有概率出现报错内容缺失或出包内容错误。\n问题分析：\n​ Gitlab 官方称：当只有一个 runner 在运行并且每个[[runner]] section 都有独立的 build 路径，concurrent 是生效的。若有多个 runner 使用同个 config.toml 文件或共享同个 build 路径，即使设置了 concurrent 为 1，也还是会有概率出现一个 runner 并发处理多个 job 的问题，官方认为这是用户的错误配置。config.toml 文件允许存在多个[[runner]] section，但这个 bug 会导致 concurrent 失效。\n​ 根据上次 ci runner 出现打包内容错误的问题推测是当时 config.toml 配置上的失误，即多个 runner 使用同个 config.toml 文件并且没有指定 build_dir（默认对应于宿主机的目录是在宿主机 的 docker volume )，因此有概率出现一个 runner 同时处理两个 job 的情况(curcurrent 设置为 1)，再加上一个 runner 映射一个 volume，从 gitlab 上拉下的源代码都存储在同个 volume，后拉的替换先拉的，最终导致必有一个 job 打出的包有问题含有其他分支的内容或直接报错编译失败。\n​ Branch_3.5.3 出的 sp4 包内容含其他分支的内容也就同样能解释通了，从下图中可以看出两次 job 先后执行并且持续了一段时间，但使用的是同一台 runner、同一个 volume，由于 Branch_3.","title":"CI Runner并行处理job有概率出现报错内容缺失或出包内容错误"},{"content":"设计模式是针对软件设计中反复出现的问题所提出的通用解决方案。它们是在大量实际软件开发经验中总结出的优秀设计实践，描述了在特定场景下解决问题的方法和思路。设计模式旨在提高代码的可复用性、可扩展性和可维护性，使软件具有更好的灵活性和稳定性。因此学习设计模式对于个人代码水平提升十分重要。\n以下为模式学习笔记汇总：\nVanilla 篇 Command pattern 命令模式\n命令模式是将方法（命令）从执行操作的对象中解耦，可以到特定时间或特定生命周期再执行命令。\nFactory pattern 工厂模式\n工厂模式是函数不通过使用 new 关键字来返回一个新对象。\nMediator/middleware pattern 中间件模式\n中间件模式使得组件可以通过一个中心点（中介者）相互交互。中间件接收请求并将其转发，使我们能够轻松简化对象之间的多对多关系。\nObserver pattern 观察者模式\n通过观察者模式，可以将某些对象（observers观察者）订阅到另一个的对象（observable可观察对象)。每当事件发生时，可观察者都会通知其所有观察者。\nMinin pattern 混合模式\nMixins 允许我们通过将功能注入到对象的原型中，轻松地向对象添加功能，而无需继承。（不推荐使用）\nSingleton pattern 单例模式\n实现单例模式是实现只能实例化一次并可以全局访问的类。\nPrototype pattern 原型模式\n原型模式是通过原型链继承的方式使得相同类型的的对象之间共享属性。\nModule Pattern 模块模式\n通过 ES Module 来防止名称冲突和全局范围污染。导出用 export，导入用 import module from path 。\nProvider Pattern 提供者模式\nProvider 模式无需通过手动给每个组件层传递数据，使得将数据传递到许多组件。\n","permalink":"https://annachengdesu.github.io/post/patterns/summary/","summary":"设计模式是针对软件设计中反复出现的问题所提出的通用解决方案。它们是在大量实际软件开发经验中总结出的优秀设计实践，描述了在特定场景下解决问题的方法和思路。设计模式旨在提高代码的可复用性、可扩展性和可维护性，使软件具有更好的灵活性和稳定性。因此学习设计模式对于个人代码水平提升十分重要。\n以下为模式学习笔记汇总：\nVanilla 篇 Command pattern 命令模式\n命令模式是将方法（命令）从执行操作的对象中解耦，可以到特定时间或特定生命周期再执行命令。\nFactory pattern 工厂模式\n工厂模式是函数不通过使用 new 关键字来返回一个新对象。\nMediator/middleware pattern 中间件模式\n中间件模式使得组件可以通过一个中心点（中介者）相互交互。中间件接收请求并将其转发，使我们能够轻松简化对象之间的多对多关系。\nObserver pattern 观察者模式\n通过观察者模式，可以将某些对象（observers观察者）订阅到另一个的对象（observable可观察对象)。每当事件发生时，可观察者都会通知其所有观察者。\nMinin pattern 混合模式\nMixins 允许我们通过将功能注入到对象的原型中，轻松地向对象添加功能，而无需继承。（不推荐使用）\nSingleton pattern 单例模式\n实现单例模式是实现只能实例化一次并可以全局访问的类。\nPrototype pattern 原型模式\n原型模式是通过原型链继承的方式使得相同类型的的对象之间共享属性。\nModule Pattern 模块模式\n通过 ES Module 来防止名称冲突和全局范围污染。导出用 export，导入用 import module from path 。\nProvider Pattern 提供者模式\nProvider 模式无需通过手动给每个组件层传递数据，使得将数据传递到许多组件。","title":"设计模式汇总及学习心得总结(Updating...)"},{"content":" 箭头函数不绑定 arguments，可以使用 ...args 代替 箭头函数没有 prototype 属性，不能进行 new 实例化 箭头函数不能通过 call、apply 等绑定 this，因为箭头函数底层是使用bind永久绑定this了，bind绑定过的this不能修改 箭头函数的this指向创建时父级的this 箭头函数不能使用yield关键字，不能作为Generator函数 const fn1 = () =\u0026gt; { // 箭头函数中没有arguments console.log(\u0026#34;arguments\u0026#34;, arguments); }; fn1(100, 300); const fn2 = () =\u0026gt; { // 这里的this指向window，箭头函数的this指向创建时父级的this console.log(\u0026#34;this\u0026#34;, this); }; // 箭头函数不能修改this fn2.call({ x: 100 }); const obj = { name: \u0026#34;poetry\u0026#34;, getName2() { // 这里的this指向obj return () =\u0026gt; { // 这里的this指向obj return this.name; }; }, getName: () =\u0026gt; { // 1、不适用箭头函数的场景1：对象方法 // 这里不能使用箭头函数，否则箭头函数指向window return this.name; }, }; obj.prototype.getName3 = () =\u0026gt; { // 2、不适用箭头函数的场景2：对象原型 // 这里不能使用箭头函数，否则this指向window return this.name; }; const Foo = (name) =\u0026gt; { // 3、不适用箭头函数的场景3：构造函数 this.name = name; }; const f = new Foo(\u0026#34;poetry\u0026#34;); // 箭头函数没有 prototype 属性，不能进行 new 实例化 const btn1 = document.getElementById(\u0026#34;btn1\u0026#34;); btn1.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { // 4、不适用箭头函数的场景4：动态上下文的回调函数 // 这里不能使用箭头函数 this === window this.innerHTML = \u0026#34;click\u0026#34;; }); // Vue 组件本质上是一个 JS 对象，this需要指向组件实例 // vue的生命周期和method不能使用箭头函数 new Vue({ data: { name: \u0026#34;poetry\u0026#34; }, methods: { // 5、不适用箭头函数的场景5：vue的生命周期和method getName: () =\u0026gt; { // 这里不能使用箭头函数，否则this指向window return this.name; }, }, mounted: () =\u0026gt; { // 这里不能使用箭头函数，否则this指向window this.getName(); }, }); // React 组件（非 Hooks）它本质上是一个 ES6 class class Foo { constructor(name) { this.name = name; } getName = () =\u0026gt; { // 这里的箭头函数this指向实例本身没有问题的 return this.name; }; } const f = new Foo(\u0026#34;poetry\u0026#34;); console.log(f.getName()); 总结：不适用箭头函数的场景\n场景 1：对象方法 场景 2：对象原型 场景 3：构造函数 场景 4：动态上下文的回调函数 场景 5：vue 的生命周期和method ","permalink":"https://annachengdesu.github.io/post/javascript/arrow-function/","summary":"箭头函数不绑定 arguments，可以使用 ...args 代替 箭头函数没有 prototype 属性，不能进行 new 实例化 箭头函数不能通过 call、apply 等绑定 this，因为箭头函数底层是使用bind永久绑定this了，bind绑定过的this不能修改 箭头函数的this指向创建时父级的this 箭头函数不能使用yield关键字，不能作为Generator函数 const fn1 = () =\u0026gt; { // 箭头函数中没有arguments console.log(\u0026#34;arguments\u0026#34;, arguments); }; fn1(100, 300); const fn2 = () =\u0026gt; { // 这里的this指向window，箭头函数的this指向创建时父级的this console.log(\u0026#34;this\u0026#34;, this); }; // 箭头函数不能修改this fn2.call({ x: 100 }); const obj = { name: \u0026#34;poetry\u0026#34;, getName2() { // 这里的this指向obj return () =\u0026gt; { // 这里的this指向obj return this.name; }; }, getName: () =\u0026gt; { // 1、不适用箭头函数的场景1：对象方法 // 这里不能使用箭头函数，否则箭头函数指向window return this.","title":"箭头函数和普通函数的区别及不适用的场景"},{"content":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。\n我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。\n假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。\nfunction App() { const data = { ... } return ( \u0026lt;div\u0026gt; \u0026lt;SideBar data={data} /\u0026gt; \u0026lt;Content data={data} /\u0026gt; \u0026lt;/div\u0026gt; ) } const SideBar = ({ data }) =\u0026gt; \u0026lt;List data={data} /\u0026gt; const List = ({ data }) =\u0026gt; \u0026lt;ListItem data={data} /\u0026gt; const ListItem = ({ data }) =\u0026gt; \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt; const Content = ({ data }) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header data={data} /\u0026gt; \u0026lt;Block data={data} /\u0026gt; \u0026lt;/div\u0026gt; ) const Header = ({ data }) =\u0026gt; \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt; const Block = ({ data }) =\u0026gt; \u0026lt;Text data={data} /\u0026gt; const Text = ({ data }) =\u0026gt; \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt; 以这种方式传递 props 可能会变得非常混乱。如果想在将来重命名 data 属性，必须在所有组件中重命名它。应用规模越大，prop 钻取就越棘手。\n如果我们能够跳过不需要使用这些数据的所有组件层，那将是最佳的。我们需要有一些东西可以让需要访问 data 值的组件直接访问它，而不依赖于 prop 钻孔。\n通过提供者模式，我们可以使得 data 供多个组件使用，可以将所有组件包装在 Provider 中，而不是通过 props 将数据传递到每一层。 Provider 是由 Context 对象提供给高阶组件。可以使用 React 提供的 createContext 方法创建一个 Context 对象。\nProvider 接收一个 value 属性，其中包含我们想要传递的数据。包含在该提供程序中的所有组件都可以访问 value 属性的值。\nconst DataContext = React.createContext() function App() { const data = { ... } return ( \u0026lt;div\u0026gt; \u0026lt;DataContext.Provider value={data}\u0026gt; \u0026lt;SideBar /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/DataContext.Provider\u0026gt; \u0026lt;/div\u0026gt; ) } 我们不再需要手动将 data 属性传递给每个组件。那么， ListItem 、 Header 和 Text 组件如何访问 data 的值呢？\n每个组件都可以通过使用 useContext 挂钩来访问 data 。此挂钩接收 data 具有引用的上下文，在本例中为 DataContext 。 useContext 钩子让我们可以读取数据并写入上下文对象。\nconst DataContext = React.createContext(); function App() { const data = { ... } return ( \u0026lt;div\u0026gt; \u0026lt;SideBar /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/div\u0026gt; ) } const SideBar = () =\u0026gt; \u0026lt;List /\u0026gt; const List = () =\u0026gt; \u0026lt;ListItem /\u0026gt; const Content = () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;Header /\u0026gt;\u0026lt;Block /\u0026gt;\u0026lt;/div\u0026gt; function ListItem() { const { data } = React.useContext(DataContext); return \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt;; } function Text() { const { data } = React.useContext(DataContext); return \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt;; } function Header() { const { data } = React.useContext(DataContext); return \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;; } 不使用 data 值的组件根本不必处理 data 。我们不再需要担心通过不需要 props 值的组件将 props 向下传递几个级别，这使得重构变得更加容易。\n提供者模式对于共享全局数据非常有用。提供者模式的一个常见用例是与许多组件共享主题 UI 状态。\n假设我们有一个显示列表的简单应用程序。\nexport const ThemeContext = React.createContext(); const themes = { light: { background: \u0026#34;#fff\u0026#34;, color: \u0026#34;#000\u0026#34;, }, dark: { background: \u0026#34;#171717\u0026#34;, color: \u0026#34;#fff\u0026#34;, }, }; export default function App() { const [theme, setTheme] = useState(\u0026#34;dark\u0026#34;); function toggleTheme() { setTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;); } const providerValue = { theme: themes[theme], toggleTheme, }; return ( \u0026lt;div className={`App theme-${theme}`}\u0026gt; \u0026lt;ThemeContext.Provider value={providerValue}\u0026gt; \u0026lt;Toggle /\u0026gt; \u0026lt;List /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; \u0026lt;/div\u0026gt; ); } 我们希望用户能够通过切换开关在浅色模式和深色模式之间切换。当用户从浅色模式切换到深色模式时，反之亦然，背景颜色和文本颜色应该改变。我们可以将组件包装在 ThemeProvider 中，并将当前主题颜色传递给提供程序，而不是将当前主题值传递给每个组件。\n由于 Toggle 和 List 组件都包装在 ThemeContext 提供程序中，因此我们可以访问值 theme 和 toggleTheme 传递给提供者。\n在 Toggle 组件中，我们可以使用 toggleTheme 函数来相应地更新主题。\nimport React, { useContext } from \u0026#34;react\u0026#34;; import { ThemeContext } from \u0026#34;./App\u0026#34;; export default function Toggle() { const theme = useContext(ThemeContext); return ( \u0026lt;label className=\u0026#34;switch\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; onClick={theme.toggleTheme} /\u0026gt; \u0026lt;span className=\u0026#34;slider round\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; ); } List 组件本身并不关心主题的当前值。但是， ListItem 组件关系。我们可以直接在 ListItem 中使用 theme 上下文。不必将任何数据传递给不关心主题当前值的组件。\nimport React, { useContext } from \u0026#34;react\u0026#34;; import { ThemeContext } from \u0026#34;./App\u0026#34;; export default function TextBox() { const theme = useContext(ThemeContext); return \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;; } Hooks 我们可以创建一个 hook 来为组件提供上下文。使用一个返回需要的上下文的钩子，而无须在每个组件中导入 useContext 和上下文。\n为了确保它是一个有效的主题，如果 useContext(ThemeContext) 返回一个虚假值，我们将抛出一个错误。\nfunction useThemeContext() { const theme = useContext(ThemeContext); if (!theme) { throw new Error(\u0026#34;useThemeContext must be used within ThemeProvider\u0026#34;); } return theme; } 我们可以创建一个 HOC 来包装组件以提供其值，而不是直接使用 ThemeContext.Provider 组件来包装组件。这样，我们可以将上下文逻辑与渲染组件分离，从而提高提供者的可重用性。\nfunction ThemeProvider({ children }) { const [theme, setTheme] = useState(\u0026#34;dark\u0026#34;); function toggleTheme() { setTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;); } const providerValue = { theme: themes[theme], toggleTheme, }; return ( \u0026lt;ThemeContext.Provider value={providerValue}\u0026gt; {children} \u0026lt;/ThemeContext.Provider\u0026gt; ); } export default function App() { return ( \u0026lt;div className={`App theme-${theme}`}\u0026gt; \u0026lt;ThemeProvider\u0026gt; \u0026lt;Toggle /\u0026gt; \u0026lt;List /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; \u0026lt;/div\u0026gt; ); } 每个需要访问 ThemeContext 的组件现在可以简单地使用 useThemeContext 钩子。\nexport default function TextBox() { const theme = useThemeContext(); return \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;; } 通过为不同的上下文创建钩子，可以轻松地将提供者的逻辑与呈现数据的组件分开。\n案例分析 一些库提供内置提供程序，我们可以在使用组件中使用这些值。一个很好的例子是styled-components。\nNo experience with styled-components is needed to understand this example.\nstyled-components库为我们提供了一个 ThemeProvider 。每个样式组件都可以访问该提供程序的值。我们可以使用提供给我们的 API，而不是自己创建上下文 API。\n让我们使用相同的 List 示例，并将组件包装在从 styled-component 库导入的 ThemeProvider 中。\nimport { ThemeProvider } from \u0026#34;styled-components\u0026#34;; export default function App() { const [theme, setTheme] = useState(\u0026#34;dark\u0026#34;); function toggleTheme() { setTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;); } return ( \u0026lt;div className={`App theme-${theme}`}\u0026gt; \u0026lt;ThemeProvider theme={themes[theme]}\u0026gt; \u0026lt;Toggle toggleTheme={toggleTheme} /\u0026gt; \u0026lt;List /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; \u0026lt;/div\u0026gt; ); } 我们不会将内联 style 属性传递给 ListItem 组件，而是将其设为 styled.li 组件。由于它是一个样式组件，我们可以访问 theme 的值。\nimport styled from \u0026#34;styled-components\u0026#34;; export default function ListItem() { return ( \u0026lt;Li\u0026gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. \u0026lt;/Li\u0026gt; ); } const Li = styled.li` ${({ theme }) =\u0026gt; ` background-color: ${theme.backgroundColor}; color: ${theme.color}; `} `; 优点 Provider 模式/Context API 使得将数据传递到许多组件成为可能，而无需手动通过每个组件层传递数据。\n它降低了重构代码时意外引入错误的风险。以前，如果我们稍后想要重命名某个 prop，则必须在使用该值的整个应用程序中重命名该 prop。\n我们不再需要处理 prop-drilling,，这可以被视为一种反模式。以前，理解应用程序的数据流可能很困难，因为并不总是清楚某些 prop 值的起源。使用 Provider 模式，我们不再需要将 props 不必要地传递给不关心这些数据的组件。\n使用提供者模式可以轻松保持某种全局状态，因为我们可以让组件访问此全局状态。\n缺点 在某些情况下，过度使用提供者模式可能会导致性能问题。所有使用上下文的组件都会在每次状态更改时重新渲染。\n举个例子，有一个简单的计数器，每次单击 Button 组件中的 Increment 按钮时，该计数器的值就会增加。在 Reset 组件中还有一个 Reset 按钮，它将计数重置回 0 。\n但是，当单击 Increment 时，会发现重新渲染的不仅仅是计数。 Reset 组件中的日期也会重新呈现。\nReset 组件也重新渲染，因为它消耗了 useCountContext 。在较小的应用程序中，这并不重要。在较大的应用程序中，将频繁更新的值传递给许多组件可能会对性能产生负面影响。\n为了确保组件不会使用包含可能更新的不必要值的 Provider，可以为特定的用例创建多个 Provider。\n","permalink":"https://annachengdesu.github.io/post/patterns/provider/","summary":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。\n我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。\n假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。\nfunction App() { const data = { ... } return ( \u0026lt;div\u0026gt; \u0026lt;SideBar data={data} /\u0026gt; \u0026lt;Content data={data} /\u0026gt; \u0026lt;/div\u0026gt; ) } const SideBar = ({ data }) =\u0026gt; \u0026lt;List data={data} /\u0026gt; const List = ({ data }) =\u0026gt; \u0026lt;ListItem data={data} /\u0026gt; const ListItem = ({ data }) =\u0026gt; \u0026lt;span\u0026gt;{data.","title":"09-Provider Pattern 提供者模式-vanilla篇"},{"content":"随着应用程序和代码库的增长，保持代码的可维护性和独立性变得越来越重要。模块模式使得代码分割成更小的、可重用的部分。\n除了此之外，模块还允许您将文件中的某些值保持为私有。默认情况下，模块内的声明的范围到该模块。如果我们不显式导出某个值，则该值在该模块之外不可用。这降低了代码库其他部分中声明的值发生名称冲突的风险，因为这些值在全局范围内不可用。\nES2015 Modules ES2015 引入了内置 JavaScript 模块。模块是包含 JavaScript 代码的文件，与普通脚本相比，其行为存在一些差异。\n让我们看一个名为 math.js 的模块示例，其中包含数学函数。\nfunction add(x, y) { return x + y; } function multiply(x) { return x * 2; } function subtract(x, y) { return x - y; } function square(x) { return x * x; } 函数允许用户进行加法、乘法、减法以及获取他们传递的值的平方。\n但是，我们不仅仅想在 math.js 文件中使用这些函数，我们希望能够在 index.js 文件中引用它们。但是直接在 index.js 文件内调用会抛出错误： index.js 文件中没有名为 add 、 subtract 、 multiply 或 square 。\n为了使 math.js 中的函数可用于其他文件，我们首先必须将它们导出。为了从模块导出代码，我们可以使用 export 关键字。导出函数的一种方法是使用命名导出：我们只需在可公开的部分前面添加 export 关键字。在这种情况下，我们需要在每个函数前面添加 export 关键字，因为 index.js 应该可以访问所有四个函数。\nexport function add(x, y) { return x + y; } export function multiply(x) { return x * 2; } export function subtract(x, y) { return x - y; } export function square(x) { return x * x; } 但仅从模块导出值并不足以使它们对所有文件公开可用。为了能够使用从模块导出的值，必须将它们显式导入到需要引用的文件中。\n必须使用 import 关键字导入 index.js 文件顶部的值。为了让 javascript 知道我们要从哪个模块导入这些函数，我们需要添加一个 from 值和模块的相对路径。\nimport { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; 拥有模块的一大好处是我们只能访问使用 export 关键字显式导出的值。我们未使用 export 关键字显式导出的值仅在该模块中可用。\n让我们创建一个只能在 math.js 文件中引用的值，称为 privateValue 。\nmath.js\nconst privateValue = \u0026#34;This is a value private to the module!\u0026#34;; index.js\nimport { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; console.log(privateValue); /* Error: privateValue is not defined */ 通过将值保持为模块私有，可以降低意外污染全局范围的风险。\n有时，导出的名称可能会与本地值发生冲突。\nmport { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; function add(...args) { return args.reduce((acc, cur) =\u0026gt; cur + acc); } /* Error: add has already been declared */ function multiply(...args) { return args.reduce((acc, cur) =\u0026gt; cur * acc); } /* Error: multiply has already been declared */ 在本例中，我们在 index.js 中有名为 add 和 multiply 的函数。如果导入具有相同名称的值，最终会导致命名冲突，不过我们可以使用 as 关键字重命名导入的值。\n让我们将导入的 add 和 multiply 函数重命名为 addValues 和 multiplyValues 。\nimport { add as addValues, multiply as multiplyValues, subtract, square, } from \u0026#34;./math.js\u0026#34;; function add(...args) { return args.reduce((acc, cur) =\u0026gt; cur + acc); } function multiply(...args) { return args.reduce((acc, cur) =\u0026gt; cur * acc); } /* From math.js module */ addValues(7, 8); multiplyValues(8, 9); subtract(10, 3); square(3); /* From index.js file */ add(8, 9, 2, 10); multiply(8, 9, 2, 10); 除了命名导出（即仅使用 export 关键字定义的导出）之外，您还可以使用默认导出。每个模块只能有一个默认导出。\n让我们将 add 函数设为默认导出，并将其他函数保留为命名导出。我们可以通过在值前面添加 export default 来导出默认值。\nexport default function add(x, y) { return x + y; } export function multiply(x) { return x * 2; } export function subtract(x, y) { return x - y; } export function square(x) { return x * x; } 命名导出和默认导出之间的区别在于从模块导出值的方式，有效地改变了我们导入值的方式。\n前面我们必须使用括号来命名导出： import { module } from 'module' 。使用默认导出，我们可以导入不带括号的值： import module from 'module' 。\nimport add, { multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; add(7, 8); multiply(8, 9); subtract(10, 3); square(3); 由于 JavaScript 知道该值始终是默认导出的值，因此我们可以为导入的默认值指定另一个名称，而不是导出时使用的名称。例如，我们可以将其称为 addValues ，而不是使用名称 add 导入 add 函数。因为 JavaScript 知道您正在导入默认导出。\nimport addValues, { multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; addValues(7, 8); multiply(8, 9); subtract(10, 3); square(3); 我们还可以通过使用星号 * 并给出我们想要导入模块的名称来导入模块中的所有导出，即所有命名导出和默认导出。导入的值等于包含所有导入值的对象。假设我想将整个模块导入为 math 。\nimport * as math from \u0026#34;./math.js\u0026#34;; import * as math from \u0026#34;./math.js\u0026#34;; math.default(7, 8); math.multiply(8, 9); math.subtract(10, 3); math.square(3); 在本例中，我们将从模块导入所有导出。执行此操作时要小心，因为您最终可能会导入不必要的值。\n使用 * 仅导入所有导出的值。模块私有的值在导入模块的文件中仍然不可用，除非您显式导出它们。\nDynamic import 动态导入 当导入文件顶部的所有模块时，所有模块都会先于文件的其余部分加载。在某些情况下，我们只需要根据某种条件导入一个模块。通过动态导入，我们可以按需导入模块。\nimport(\u0026#34;module\u0026#34;).then((module) =\u0026gt; { module.default(); module.namedExport(); }); // Or with async/await (async () =\u0026gt; { const module = await import(\u0026#34;module\u0026#34;); module.default(); module.namedExport(); })(); 让我们动态导入前面段落中使用的 math.js 示例。\n仅当用户单击按钮时，该模块才会加载。\nconst button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { import(\u0026#34;./math.js\u0026#34;).then((module) =\u0026gt; { console.log(\u0026#34;Add: \u0026#34;, module.add(1, 2)); console.log(\u0026#34;Multiply: \u0026#34;, module.multiply(3, 2)); const button = document.getElementById(\u0026#34;btn\u0026#34;); button.innerHTML = \u0026#34;Check the console\u0026#34;; }); }); /*************************** */ /**** Or with async/await ****/ /*************************** */ // button.addEventListener(\u0026#34;click\u0026#34;, async () =\u0026gt; { // const module = await import(\u0026#34;./math.js\u0026#34;); // console.log(\u0026#34;Add: \u0026#34;, module.add(1, 2)); // console.log(\u0026#34;Multiply: \u0026#34;, module.multiply(3, 2)); // }); 通过动态导入模块，我们可以减少页面加载时间。我们只需在用户需要时加载、解析和编译用户真正需要的代码。\n除了能够按需导入模块之外， import() 函数还可以接收表达式。它允许我们传递模板文字，以便根据给定值动态加载模块。\nimport moment from \u0026#34;moment\u0026#34;; export const getCurrentTime = () =\u0026gt; { const date = moment().format(\u0026#34;MMMM Do YYYY, h:mm:ss a\u0026#34;); return `Currently, it is ${date}`; }; export const getCurrentDay = () =\u0026gt; { const day = moment().format(\u0026#34;dddd\u0026#34;); return `It is ${day} today`; }; import React from \u0026#34;react\u0026#34;; export function Date() { const [currentTime, setCurrentTime] = React.useState(\u0026#34;\u0026#34;); const [currentDay, setCurrentDay] = React.useState(\u0026#34;\u0026#34;); async function loadDates() { const module = await import(\u0026#34;../utils/date\u0026#34;); setCurrentTime(module.getCurrentTime()); setCurrentDay(module.getCurrentDay()); } return currentTime \u0026amp;\u0026amp; currentDay ? ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{currentTime}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{currentDay}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) : ( \u0026lt;button onClick={loadDates}\u0026gt;Click to load dates\u0026lt;/button\u0026gt; ); } 在上面的示例中，仅当用户单击“Click to load dates”按钮时才会导入 date.js 模块。 date.js 模块导入第三方 moment 模块，该模块仅在 date.js 模块加载时导入。如果用户不需要显示日期，我们可以完全避免加载这个第三方库。\n用户单击“单击加载图像”按钮后，将加载每个图像。图像是本地 .png 文件，根据我们传递给字符串的 num 值加载。\nconst res = await import(`../assets/dog${num}.png`); 这样，我们就不再依赖于硬编码的模块路径。它为您根据用户输入、从外部源接收的数据、函数结果等导入模块的方式增加了灵活性。\nSummary 通过模块模式，我们可以封装不应该公开的部分代码。这可以防止意外的名称冲突和全局范围污染，从而降低使用多个依赖项和命名空间的风险。为了能够在所有 JavaScript 运行时中使用 ES2015 Module，需要通过类似 Babel 这样的转译器进行转译。\n","permalink":"https://annachengdesu.github.io/post/patterns/module/","summary":"随着应用程序和代码库的增长，保持代码的可维护性和独立性变得越来越重要。模块模式使得代码分割成更小的、可重用的部分。\n除了此之外，模块还允许您将文件中的某些值保持为私有。默认情况下，模块内的声明的范围到该模块。如果我们不显式导出某个值，则该值在该模块之外不可用。这降低了代码库其他部分中声明的值发生名称冲突的风险，因为这些值在全局范围内不可用。\nES2015 Modules ES2015 引入了内置 JavaScript 模块。模块是包含 JavaScript 代码的文件，与普通脚本相比，其行为存在一些差异。\n让我们看一个名为 math.js 的模块示例，其中包含数学函数。\nfunction add(x, y) { return x + y; } function multiply(x) { return x * 2; } function subtract(x, y) { return x - y; } function square(x) { return x * x; } 函数允许用户进行加法、乘法、减法以及获取他们传递的值的平方。\n但是，我们不仅仅想在 math.js 文件中使用这些函数，我们希望能够在 index.js 文件中引用它们。但是直接在 index.js 文件内调用会抛出错误： index.js 文件中没有名为 add 、 subtract 、 multiply 或 square 。\n为了使 math.js 中的函数可用于其他文件，我们首先必须将它们导出。为了从模块导出代码，我们可以使用 export 关键字。导出函数的一种方法是使用命名导出：我们只需在可公开的部分前面添加 export 关键字。在这种情况下，我们需要在每个函数前面添加 export 关键字，因为 index.","title":"08-Module Pattern 模块模式-vanilla篇"},{"content":"原型模式是在同一类型的许多对象之间共享属性的有用方法。原型是 JavaScript 原生的对象，可以通过原型链被对象访问。\n在我们的应用程序中，我们经常需要创建许多相同类型的对象。想要达到此目的可以通过 ES6 类创建多个实例。\n假设我们想创造很多狗，他们有一个名字，并且它们可以吠叫。\nclass Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); 请注意这里 constructor 如何包含 name 属性，并且类本身如何包含 bark 属性。使用 ES6 类时，类本身定义的所有属性（在本例中为 bark ）都会自动添加到 prototype 中。\n我们可以通过访问构造函数上的 prototype 属性或通过任何实例上的 __proto__ 属性直接查看 prototype 。\nconsole.log(Dog.prototype); // constructor: ƒ Dog(name, breed) bark: ƒ bark() console.log(dog1.__proto__); // constructor: ƒ Dog(name, breed) bark: ƒ bark() 构造函数的任何实例上的 __proto__ 值都是对构造函数原型的直接引用。每当我们尝试直接访问对象上不存在的对象属性时，JavaScript 就会沿着原型链向下查找该属性在原型链中是否可用。\n当处理应该有权访问相同属性的对象时，原型模式非常强大。我们可以简单地将属性添加到原型中，而不是每次都创建属性的副本，因为所有实例都可以访问原型对象。\n由于所有实例都可以访问原型，因此即使在创建实例之后也可以轻松向原型添加属性。\n说我们的狗不仅应该会叫，还应该会玩，可以通过向原型添加 play 属性来实现这一点。\nclass Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); Dog.prototype.play = () =\u0026gt; console.log(\u0026#34;Playing now!\u0026#34;); dog1.play(); 原型链这一术语表明可以有多个步骤。到目前为止，我们只了解了如何访问 __proto__ 引用的第一个对象上直接可用的属性。然而，原型本身也有一个 __proto__ 对象。\n让我们创造另一种狗，一只超级狗。这只狗应该继承普通 Dog 的一切，但它也应该能够飞。我们可以通过扩展 Dog 类并添加 fly 方法来创建超级狗。\nclass Dog { constructor(name) { this.name = name; } bark() { console.log(\u0026#34;Woof!\u0026#34;); } } class SuperDog extends Dog { constructor(name) { super(name); } fly() { console.log(`Flying!`); } } const dog1 = new SuperDog(\u0026#34;Daisy\u0026#34;); dog1.bark(); dog1.fly(); 当我们扩展 Dog 类时，我们可以访问 bark 方法。 SuperDog 原型上 __proto__ 的值指向 Dog.prototype 对象。\n这也就能很清楚认识到为什么它被称为原型链：当我们尝试访问对象上不直接可用的属性时，JavaScript 会递归地遍历 __proto__ 指向的所有对象，直到找到该属性。\nObject.create Object.create 方法允许我们创建一个新对象，我们可以显式地将其原型值传递给该对象。\nconst dog = { bark() { return `Woof!`; }, }; const pet1 = Object.create(dog); pet1.bark(); // Woof! console.log(\u0026#34;Direct properties on pet1: \u0026#34;, Object.keys(pet1)); console.log(\u0026#34;Properties on pet1\u0026#39;s prototype: \u0026#34;, Object.keys(pet1.__proto__)); 虽然 pet1 本身没有任何属性，但它确实可以访问其原型链上的属性。由于我们将 dog 对象作为 pet1 的原型传递，因此我们可以访问 bark 属性。\nObject.create 是一种简单的方法，通过指定新创建的对象的原型，让对象直接从其他对象继承属性。新对象可以通过沿着原型链向下访问新属性。\n原型模式允许我们轻松地让对象访问并继承其他对象的属性。由于原型链允许我们访问对象本身没有直接定义的属性，因此我们可以避免方法和属性的重复，从而减少内存使用量。\n","permalink":"https://annachengdesu.github.io/post/patterns/prototype/","summary":"原型模式是在同一类型的许多对象之间共享属性的有用方法。原型是 JavaScript 原生的对象，可以通过原型链被对象访问。\n在我们的应用程序中，我们经常需要创建许多相同类型的对象。想要达到此目的可以通过 ES6 类创建多个实例。\n假设我们想创造很多狗，他们有一个名字，并且它们可以吠叫。\nclass Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); 请注意这里 constructor 如何包含 name 属性，并且类本身如何包含 bark 属性。使用 ES6 类时，类本身定义的所有属性（在本例中为 bark ）都会自动添加到 prototype 中。\n我们可以通过访问构造函数上的 prototype 属性或通过任何实例上的 __proto__ 属性直接查看 prototype 。\nconsole.log(Dog.prototype); // constructor: ƒ Dog(name, breed) bark: ƒ bark() console.log(dog1.__proto__); // constructor: ƒ Dog(name, breed) bark: ƒ bark() 构造函数的任何实例上的 __proto__ 值都是对构造函数原型的直接引用。每当我们尝试直接访问对象上不存在的对象属性时，JavaScript 就会沿着原型链向下查找该属性在原型链中是否可用。","title":"07-Prototype Pattern 原型模式-vanilla篇"},{"content":"单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。\n首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：\n返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。\nlet counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.log(counter1.getInstance() === counter2.getInstance()); // false 通过调用 new 方法两次，我们只需将 counter1 和 counter2 设置为等于不同的实例。 counter1 和 counter2 上的 getInstance 方法返回的值实际上返回了对不同实例的引用：它们并不严格相等。\n让我们确保只能创建 Counter 类的一个实例。\n确保只能创建一个实例的一种方法是创建一个名为 instance 的变量。在 Counter 的构造函数中，我们可以在创建新实例时将 instance 设置为对该实例的引用。我们可以通过检查 instance 变量是否已经有值来防止新的实例化。如果是这种情况，则实例已经存在。这种情况不应该发生：应该抛出错误让用户知道。\nlet instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;You can only create one instance!\u0026#34;); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); // Error: You can only create one instance! 我们无法再创建多个实例。\n让我们从 counter.js 文件中导出 Counter 实例。但在此之前，我们也应该冻结实例。 Object.freeze 方法确保使用代码无法修改单例。无法添加或修改冻结实例上的属性，这降低了意外覆盖单例上的值的风险。\nlet instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;You can only create one instance!\u0026#34;); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter; 让我们看一下实现 Counter 示例的应用程序。我们有以下文件：\ncounter.js ：包含 Counter 类，并导出 Counter 实例作为其默认导出\nindex.js ：加载 redButton.js 和 blueButton.js 模块\nredButton.js: 导入 Counter, 并将 Counter的 increment 方法添加为红色按钮的事件监听器，并记录当前值通过调用 getCount 方法来实现counter\nblueButton.js ：导入 Counter ，并将 Counter 的 increment 方法作为事件侦听器添加到蓝色按钮，并记录当前值通过调用 getCount 方法来实现 counter\nblueButton.js 和 redButton.js 都从 counter.js 导入相同的实例。该实例在两个文件中均作为 Counter 导入。\n当我们在 redButton.js 或 blueButton.js 中调用 increment 方法时， Counter 属性的值\u0026gt; 两个文件中的实例更新。我们点击红色还是蓝色按钮并不重要：所有实例共享相同的值。这就是为什么即使我们在不同的文件中调用该方法，计数器也会不断增加 1。\n权衡 将实例化限制为仅一个实例可能会节省大量内存空间。我们不必每次都为一个新实例设置内存，而只需为该一个实例设置内存，该实例在整个应用程序中都会被引用。然而，单例实际上被认为是一种反模式，并且可以（或..应该）在 JavaScript 中避免。\n在许多编程语言中，例如 Java 或 C++，不可能像 JavaScript 那样直接创建对象。在那些面向对象的编程语言中，我们需要创建一个类，它创建一个对象。创建的对象具有类实例的值，就像 JavaScript 示例中 instance 的值一样。\n然而，上面示例中显示的类实现实际上是多余的。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。让我们来看看使用单例的一些缺点。\n使用常规对象 让我们使用之前看到的相同示例。然而这一次， counter 只是一个包含以下内容的对象：\na count property count 属性 将 count 的值增加 1 的 increment 方法 将 count 的值减一的 decrement 方法 let count = 0; const counter = { increment() { return ++count; }, decrement() { return --count; }, }; Object.freeze(counter); export { counter }; 由于对象是通过引用传递的，因此 redButton.js 和 blueButton.js 都导入对同一 counter 对象的引用。修改这两个文件中的 count 的值将修改 counter 上的值，该值在这两个文件中都可见。\n测试 测试依赖于单例的代码可能会很棘手。由于我们无法每次都创建新实例，因此所有测试都依赖于对上一次测试的全局实例的修改。在这种情况下，测试的顺序很重要，一个小的修改可能会导致整个测试套件失败。测试完成后，我们需要重置整个实例，以重置测试所做的修改。\nmport Counter from \u0026#34;../src/counterTest\u0026#34;; test(\u0026#34;incrementing 1 time should be 1\u0026#34;, () =\u0026gt; { Counter.increment(); expect(Counter.getCount()).toBe(1); }); test(\u0026#34;incrementing 3 extra times should be 4\u0026#34;, () =\u0026gt; { Counter.increment(); Counter.increment(); Counter.increment(); expect(Counter.getCount()).toBe(4); }); test(\u0026#34;decrementing 1 times should be 3\u0026#34;, () =\u0026gt; { Counter.decrement(); expect(Counter.getCount()).toBe(3); }); 依赖隐藏 当导入另一个模块时，在这种情况下 superCounter.js ，模块正在导入 Singleton 可能并不明显。在其他文件中，例如本例中的 index.js ，我们可能会导入该模块并调用其方法。这样，我们就无意中修改了 Singleton 中的值。这可能会导致意外的行为，因为单例的多个实例可以在整个应用程序中共享，这些实例也都会被修改。\nimport Counter from \u0026#34;./counter\u0026#34;; export default class SuperCounter { constructor() { this.count = 0; } increment() { Counter.increment(); return (this.count += 100); } decrement() { Counter.decrement(); return (this.count -= 100); } } 全局行为 Singleton 实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，因此我们可以在整个应用程序中访问这些变量。\n拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，这可能会导致许多意外行为。\n在 ES2015 中，创建全局变量相当罕见。新的 let 和 const 关键字通过将使用这两个关键字声明的变量保持在块范围内，可以防止开发人员意外污染全局范围。 JavaScript 中的新 module 系统可以更轻松地创建全局可访问的值，而不会污染全局范围，因为能够从模块获取 export 值，以及 import 这些值在其他文件中。\n然而，单例的常见用例是在整个应用程序中拥有某种全局状态。让代码库的多个部分依赖于同一个可变对象可能会导致意外的行为。\n通常，代码库的某些部分会修改全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据可供使用时意外地首先使用数据。随着应用程序的增长，并且数十个组件相互依赖，理解使用全局状态时的数据流可能会变得非常棘手。\nReact 中的状态管理 在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用单例。尽管它们的全局状态行为可能看起来与单例的行为类似，但这些工具提供只读状态而不是单例的可变状态。使用 Redux 时，在组件通过dispatcher发送操作后，只有纯函数reducers才能更新状态。\n尽管使用这些工具并不会神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们预期的方式发生变化，因为组件无法直接更新状态。\n","permalink":"https://annachengdesu.github.io/post/patterns/singleton/","summary":"单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。\n首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：\n返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。\nlet counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.","title":"06-Singleton Pattern 单例模式-vanilla篇"},{"content":"通过观察者模式，我们可以将某些对象（观察者）订阅到另一个称为可观察对象的对象。每当事件发生时，可观察者都会通知其所有观察者。\n一个可观察对象通常包含 3 个重要部分：\nobservers ：观察者数组，每当特定事件发生时都会收到通知\nsubscribe() ：将观察者添加到观察者列表的方法\nunsubscribe() ：从观察者列表中删除观察者的方法\nnotify() ：每当特定事件发生时通知所有观察者的方法\n创建一个简单的方法是使用 ES6 类。\nclass Observable { constructor() { this.observers = []; } subscribe(func) { this.observers.push(func); } unsubscribe(func) { this.observers = this.observers.filter((observer) =\u0026gt; observer !== func); } notify(data) { this.observers.forEach((observer) =\u0026gt; observer(data)); } } 我们现在可以使用 subscribe 方法将观察者添加到观察者列表中，使用 unsubscribe 方法删除观察者，并使用 notify 方法通知所有订阅者。\n现在我们有一个非常基本的应用程序，仅包含两个组件： Button 和 Switch 。\nexport default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); } 我们希望跟踪用户与应用程序的交互。每当用户单击按钮或切换开关时，我们都希望使用时间戳记录此事件。除了记录之外，我们还想创建一个 Toast 通知，每当事件发生时就会显示。\n每当用户调用 handleClick 或 handleToggle 函数时，这些函数都会调用观察者上的 notify 方法。 notify 方法用 handleClick 或 handleToggle 函数传递的数据通知所有订阅者。\n首先，让我们创建 logger 和 toastify 函数。这些函数最终将从 notify 方法接收 data 。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data); } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 目前， logger 和 toastify 函数不知道 observable，observable 还无法通知它们。为了使它们成为观察者，我们必须使用可观察对象上的 subscribe 方法来订阅它们。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data); } observable.subscribe(logger); observable.subscribe(toastify); export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 每当事件发生时， logger 和 toastify 函数都会收到通知。现在我们只需要实现实际通知可观察对象的函数： handleClick 和 handleToggle 函数。这些函数应该调用可观察对象的 notify 方法，并传递观察者应该接收的数据。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data, { position: toast.POSITION.BOTTOM_RIGHT, closeButton: false, autoClose: 2000, }); } function handleClick() { observable.notify(\u0026#34;User clicked button!\u0026#34;); } function handleToggle() { observable.notify(\u0026#34;User toggled switch!\u0026#34;); } observable.subscribe(logger); observable.subscribe(toastify); export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button variant=\u0026#34;contained\u0026#34; onClick={handleClick}\u0026gt; Click me! \u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch name=\u0026#34;\u0026#34; onChange={handleToggle} /\u0026gt;} label=\u0026#34;Toggle me!\u0026#34; /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 我们刚刚完成了整个流程： handleClick 和 handleToggle 用数据调用观察者上的 notify 方法，之后观察者通知订阅者： logger 和 toastify 在这种情况下起作用。\n每当用户与任一组件交互时， logger 和 toastify 函数都会收到我们传递给 notify 方法的数据的通知。\n我们可以通过多种方式使用观察者模式，它在处理异步、基于事件的数据时非常有用。当你希望每在某些数据下载完成时，或者每当用户向留言板发送新消息时，某些组件都会收到通知，并且所有其他成员都应该收到通知。\n案例分析 使用可观察模式的流行库有 RxJS。\nReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events. - RxJS\n使用 RxJS，我们可以创建可观察对象并订阅某些事件。让我们看一下他们的文档中包含的一个示例，该示例记录用户是否在文档中拖动。\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import { fromEvent, merge } from \u0026#34;rxjs\u0026#34;; import { sample, mapTo } from \u0026#34;rxjs/operators\u0026#34;; import \u0026#34;./styles.css\u0026#34;; merge( fromEvent(document, \u0026#34;mousedown\u0026#34;).pipe(mapTo(false)), fromEvent(document, \u0026#34;mousemove\u0026#34;).pipe(mapTo(true)) ) .pipe(sample(fromEvent(document, \u0026#34;mouseup\u0026#34;))) .subscribe((isDragging) =\u0026gt; { console.log(\u0026#34;Were you dragging?\u0026#34;, isDragging); }); ReactDOM.render( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;Click or drag anywhere and check the console!\u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); RxJS 具有大量与可观察模式配合使用的内置功能和示例。\n优点 使用观察者模式是强制关注点分离和单一职责原则的好方法。观察者对象与可观察对象并不紧密耦合，并且可以随时解耦。可观察对象负责监视事件，而观察者只处理接收到的数据。\n缺点 如果观察者变得过于复杂，则在通知所有订阅者时可能会导致性能问题。\n","permalink":"https://annachengdesu.github.io/post/patterns/observer/","summary":"通过观察者模式，我们可以将某些对象（观察者）订阅到另一个称为可观察对象的对象。每当事件发生时，可观察者都会通知其所有观察者。\n一个可观察对象通常包含 3 个重要部分：\nobservers ：观察者数组，每当特定事件发生时都会收到通知\nsubscribe() ：将观察者添加到观察者列表的方法\nunsubscribe() ：从观察者列表中删除观察者的方法\nnotify() ：每当特定事件发生时通知所有观察者的方法\n创建一个简单的方法是使用 ES6 类。\nclass Observable { constructor() { this.observers = []; } subscribe(func) { this.observers.push(func); } unsubscribe(func) { this.observers = this.observers.filter((observer) =\u0026gt; observer !== func); } notify(data) { this.observers.forEach((observer) =\u0026gt; observer(data)); } } 我们现在可以使用 subscribe 方法将观察者添加到观察者列表中，使用 unsubscribe 方法删除观察者，并使用 notify 方法通知所有订阅者。\n现在我们有一个非常基本的应用程序，仅包含两个组件： Button 和 Switch 。\nexport default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); } 我们希望跟踪用户与应用程序的交互。每当用户单击按钮或切换开关时，我们都希望使用时间戳记录此事件。除了记录之外，我们还想创建一个 Toast 通知，每当事件发生时就会显示。","title":"05-Observer Pattern 观察者模式-vanilla篇"},{"content":"mixin 是一个对象，我们可以使用它向另一个对象或类添加可重用的功能，而无需使用继承。我们不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类添加功能。\n假设我们的应用程序需要创建多只狗。然而，我们创建的基本狗除了 name 属性之外没有任何属性。\nclass Dog { constructor(name) { this.name = name; } } 狗应该能够做的不仅仅是有名字。它应该能够吠叫、摇尾巴和玩耍！我们可以创建一个 mixin 来为我们提供 bark 、 wagTail 和 play 属性，而不是直接将其添加到 Dog 中。\nconst dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; 我们可以使用 Object.assign 方法将 dogFunctionality mixin 添加到 Dog 原型中。此方法允许我们向目标对象添加属性：在本例中为 Dog.prototype 。 Dog 的每个新实例都可以访问 dogFunctionality 的属性，因为它们被添加到 Dog 的原型中。\nclass Dog { constructor(name) { this.name = name; } } const dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; Object.assign(Dog.prototype, dogFunctionality); 让我们创建我们的第一个宠物 pet1 ，名为 Daisy。由于我们刚刚将 dogFunctionality mixin 添加到 Dog 的原型中，Daisy 应该能够走路、摇尾巴和玩耍！\nconst pet1 = new Dog(\u0026#34;Daisy\u0026#34;); pet1.name; // Daisy pet1.bark(); // Woof! pet1.play(); // Playing! Mixins 使我们可以轻松地向类或对象添加自定义功能，而无需使用继承。\n虽然我们可以使用 mixins 添加功能而无需继承，但 mixins 本身可以使用继承。大多数哺乳动物（除了海豚……也许还有更多）也可以行走和睡眠。狗是哺乳动物，应该能够行走和睡觉。\n让我们创建一个添加 walk 和 sleep 属性的 animalFunctionality mixin。\nconst animalFunctionality = { walk: () =\u0026gt; console.log(\u0026#34;Walking!\u0026#34;), sleep: () =\u0026gt; console.log(\u0026#34;Sleeping!\u0026#34;), }; 我们可以使用 Object.assign 将这些属性添加到 dogFunctionality 原型中。在本例中，目标对象是 dogFunctionality 。\nconst animalFunctionality = { walk: () =\u0026gt; console.log(\u0026#34;Walking!\u0026#34;), sleep: () =\u0026gt; console.log(\u0026#34;Sleeping!\u0026#34;), }; const dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), walk() { super.walk(); }, sleep() { super.sleep(); }, }; Object.assign(dogFunctionality, animalFunctionality); Object.assign(Dog.prototype, dogFunctionality); 现在Dog 的任何新实例现在也可以访问 walk 和 sleep 方法。\nconst pet1 = new Dog(\u0026#34;Daisy\u0026#34;); console.log(pet1.name); pet1.bark(); pet1.play(); pet1.walk(); pet1.sleep(); 现实世界中 mixin 的示例在浏览器环境中的 Window 界面上可见。 Window 对象实现了许多如 WindowOrWorkerGlobalScope 和 WindowEventHandlers的 mixin 属性，这使得我们能够访问 setTimeout 等属性和 setInterval 、 indexedDB 和 isSecureContext 。\n由于它是一个 mixin，因此仅用于向对象添加功能，因此您将无法创建 WindowOrWorkerGlobalScope 类型的对象。\nwindow.indexedDB.open(\u0026#34;toDoList\u0026#34;); window.addEventListener(\u0026#34;beforeunload\u0026#34;, (event) =\u0026gt; { event.preventDefault(); event.returnValue = \u0026#34;\u0026#34;; }); window.onbeforeunload = function () { console.log(\u0026#34;Unloading!\u0026#34;); }; console.log( \u0026#34;From WindowEventHandlers mixin: onbeforeunload\u0026#34;, window.onbeforeunload ); console.log( \u0026#34;From WindowOrWorkerGlobalScope mixin: isSecureContext\u0026#34;, window.isSecureContext ); console.log( \u0026#34;WindowEventHandlers itself is undefined\u0026#34;, window.WindowEventHandlers ); console.log( \u0026#34;WindowOrWorkerGlobalScope itself is undefined\u0026#34;, window.WindowOrWorkerGlobalScope ); React (pre ES6) 在引入 ES6 类之前，Mixin 通常用于向 React 组件添加功能。 React 团队不鼓励使用 mixins，因为它很容易给组件增加不必要的复杂性，使其难以维护和重用。 React 团队鼓励使用更高阶的组件，现在这些组件通常可以被 Hook 取代。\nMixins 允许我们通过将功能注入到对象的原型中，轻松地向对象添加功能，而无需继承。修改对象的原型被认为是不好的做法，因为它可能导致原型污染以及函数起源的一定程度的不确定性。\n","permalink":"https://annachengdesu.github.io/post/patterns/minin/","summary":"mixin 是一个对象，我们可以使用它向另一个对象或类添加可重用的功能，而无需使用继承。我们不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类添加功能。\n假设我们的应用程序需要创建多只狗。然而，我们创建的基本狗除了 name 属性之外没有任何属性。\nclass Dog { constructor(name) { this.name = name; } } 狗应该能够做的不仅仅是有名字。它应该能够吠叫、摇尾巴和玩耍！我们可以创建一个 mixin 来为我们提供 bark 、 wagTail 和 play 属性，而不是直接将其添加到 Dog 中。\nconst dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; 我们可以使用 Object.assign 方法将 dogFunctionality mixin 添加到 Dog 原型中。此方法允许我们向目标对象添加属性：在本例中为 Dog.prototype 。 Dog 的每个新实例都可以访问 dogFunctionality 的属性，因为它们被添加到 Dog 的原型中。\nclass Dog { constructor(name) { this.name = name; } } const dogFunctionality = { bark: () =\u0026gt; console.","title":"04-Mixin Pattern 混合模式-vanilla篇"},{"content":"中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在 Javascript 中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.send(\u0026#34;Hi there!\u0026#34;); user2.send(\u0026#34;Hey!\u0026#34;); 案例分析 Express.js 是一种流行的 Web 应用程序服务器框架。我们可以向用户可以访问的某些路由添加回调。\n假设如果用户点击根路径 '/' ，我们希望向请求添加一个标头。我们可以在中间件回调中添加此标头。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use(\u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }); next 方法调用请求-响应周期中的下一个回调。我们将有效地创建位于请求和响应之间的中间件功能链，反之亦然。\n让我们添加另一个中间件函数来检查 test-header 是否已正确添加。之前的中间件功能添加的更改将在整个链中可见。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use( \u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }, (req, res, next) =\u0026gt; { console.log(`Request has test header: ${!!req.headers[\u0026#34;test-header\u0026#34;]}`); next(); } ); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;); res.send(Buffer.from(html)); }); app.listen(8080, function () { console.log(\u0026#34;Server is running on 8080\u0026#34;); }); 我们可以通过一个或多个中间件函数跟踪和修改请求对象一直到响应。\n每次用户点击根端点 '/' 时，都会调用两个中间件回调。\n总结 中间件模式让所有通信都流经一个中心点，使我们能够轻松简化对象之间的多对多关系。\n","permalink":"https://annachengdesu.github.io/post/patterns/mediator/","summary":"中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在 Javascript 中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.","title":"03-Mediator/Middleware Pattern 中介者/中间件模式-vanilla篇"},{"content":"使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。\n让我们重构 OrderManager 类：它不再具有 placeOrder 、 cancelOrder 和 trackOrder 方法，而是只有一个方法： execute 。该方法将执行它给出的任何命令。\nclass OrderManager { constructor() { this.orders = []; } execute(command, ...args) { return command.execute(this.orders, ...args); } } 还需要为订单管理器创建三个 Command ：\nclass Command { constructor(execute) { this.execute = execute; } } function PlaceOrderCommand(order, id) { return new Command((orders) =\u0026gt; { orders.push(id); return `You have successfully ordered ${order} (${id})`; }); } function CancelOrderCommand(id) { return new Command((orders) =\u0026gt; { orders = orders.filter((order) =\u0026gt; order.id !== id); return `You have canceled your order ${id}`; }); } function TrackOrderCommand(id) { return new Command(() =\u0026gt; `Your order ${id} will arrive in 20 minutes.`); } const manager = new OrderManager(); manager.execute(new PlaceOrderCommand(\u0026#34;noodle\u0026#34;, \u0026#34;1234\u0026#34;)); manager.execute(new TrackOrderCommand(\u0026#34;1234\u0026#34;)); manager.execute(new CancelOrderCommand(\u0026#34;1234\u0026#34;)); 这些方法不再直接耦合到 OrderManager 实例，而是现在是独立的解耦函数，我们可以通过 OrderManager 方法调用它们。\n优点 命令模式允许我们将方法从执行操作的对象中解耦。它能够更加灵活的控制，比如一些具有生命周期的命令，又或者需要在特定时间排队并执行的命令。\n缺点 命令模式的用例非常有限，并且经常向应用程序添加不必要的样板。\n","permalink":"https://annachengdesu.github.io/post/patterns/command/","summary":"使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。","title":"01-Command Pattern 命令模式-vanilla篇"},{"content":"Redux 基本概念与 API Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\nStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。\nState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。\nAction 是一个对象。其中的type属性是必须的，表示 Action 的名称。\nAction 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\nReducer 是一个函数，它接受 当前 State 和 Action 作为参数，返回一个新的 State。\nStore 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。\nstore 的三个方法 store.getState() // 获取当前 state store.dispatch() // 派发 action 至 reducer 处理 store.subscribe() // 订阅事件 state 变化即触发 示例代码 实现一个能够添加书籍，并能够根据书籍 ID 删除的功能。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Redux example\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;addBook\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;addInput\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;addBtn\u0026#34;\u0026gt;ADD Book\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;delBook\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;delInput\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;delBtn\u0026#34;\u0026gt;DEL Book\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ol id=\u0026#34;bookList\u0026#34;\u0026gt;\u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; import { legacy_createStore as createStore } from \u0026#34;redux\u0026#34;; const initialState = []; let recordState; const reducer = (state = initialState, action) =\u0026gt; { recordState = state; switch (action.type) { case \u0026#34;ADD_BOOK\u0026#34;: return [ ...state, { bookId: action.info.bookId, bookName: action.info.bookName, }, ]; case \u0026#34;DEL_BOOK\u0026#34;: return state.filter((book) =\u0026gt; book.bookId != action.info.bookId); default: return [...state]; } }; const store = createStore(reducer); const addInput = document.getElementById(\u0026#34;addInput\u0026#34;); const delInput = document.getElementById(\u0026#34;delInput\u0026#34;); const addBtn = document.getElementById(\u0026#34;addBtn\u0026#34;); const delBtn = document.getElementById(\u0026#34;delBtn\u0026#34;); const bookList = document.getElementById(\u0026#34;bookList\u0026#34;); function* generateId() { let i = 0; while (true) { yield ++i; } } const generateID = generateId(); const bookId = () =\u0026gt; generateID.next().value; function addBookFn() { const bookName = addInput.value; if (bookName.trim()) { addInput.value = \u0026#34;\u0026#34;; const id = bookId(); store.dispatch({ type: \u0026#34;ADD_BOOK\u0026#34;, info: { bookName, bookId: id, }, }); } } function delBookFn() { const bookId = delInput.value.trim(); const books = store.getState(); const isExist = books.find((book) =\u0026gt; book.bookId == bookId); if (isExist) { delInput.value = \u0026#34;\u0026#34;; store.dispatch({ type: \u0026#34;DEL_BOOK\u0026#34;, info: { bookId, }, }); } } addBtn.addEventListener(\u0026#34;click\u0026#34;, addBookFn); delBtn.addEventListener(\u0026#34;click\u0026#34;, delBookFn); function createBookItem(book) { const element = document.createElement(\u0026#34;li\u0026#34;); element.innerText = `BookID: ${book.bookId} Name: ${book.bookName}`; return element; } const showBookList = store.subscribe(() =\u0026gt; { const newBookList = store.getState(); if (newBookList.length !== recordState.length) { bookList.innerText = \u0026#34;\u0026#34;; newBookList.forEach((book) =\u0026gt; { bookList.appendChild(createBookItem(book)); }); } }); 直接使用 Redux 存在的常见问题 配置复杂，devtool\u0026hellip; 模板代码太多，创建 constant，action，reducer\u0026hellip; 需要添加很多依赖包，如 redux-thunk、immer\u0026hellip; Redux-toolkit 解决了哪些问题 configureStore() 包裹 createStore，并集成了redux-thunk、Redux DevTools Extension，默认开启\ncreateReducer() 创建一个 reducer，action type 映射到 case reducer 函数中，不用写 switch-case，并集成`immer\ncreateAction() 创建一个 action，传入动作类型字符串，返回动作函数\ncreateSlice() 创建一个 slice，包含 createReducer、createAction 的所有功能\ncreateAsyncThunk() 创建一个 thunk，接受一个动作类型字符串和一个 Promise 的函数\nRedux-toolkit 替换 Redex 示例代码 安装@reduxjs/toolkit # 使用 npm\rnpm install @reduxjs/toolkit\r# 使用 yarn\ryarn add @reduxjs/toolkit configureStore 替换 createStore import React from \u0026#34;react\u0026#34;; import { render } from \u0026#34;react-dom\u0026#34;; // import { createStore } from \u0026#34;redux\u0026#34;; import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import App from \u0026#34;./components/App\u0026#34;; import rootReducer from \u0026#34;./reducers\u0026#34;; // const store = createStore(rootReducer); const store = configureStore({ reducer: rootReducer, }); 创建 Action # 创建 action const increment = createAction(\u0026#39;INCREMENT\u0026#39;) const decrement = createAction(\u0026#39;DECREMENT\u0026#39;) # 创建reducer const counter = createReducer(0, { [increment]: state =\u0026gt; state + 1, [decrement]: state =\u0026gt; state - 1 }) 以上看起比原来结构上好一些，创建 action、reducer 方便了，但是看着还是不爽，action 也可以去掉。\n创建 Slice const counterSlice = createSlice({ name: \u0026#39;counter\u0026#39;, initialState: 0, reducers: { increment: state =\u0026gt; state + 1, decrement: state =\u0026gt; state - 1 } }) # action counterSlice.action; # reducer counterSlice.reducer; 完整 slice import { createSlice, PayloadAction } from \u0026#34;@reduxjs/toolkit\u0026#34;; import { AppThunk, RootState } from \u0026#34;../../app/store\u0026#34;; interface CounterState { value: number; } const initialState: CounterState = { value: 0, }; export const counterSlice = createSlice({ name: \u0026#34;counter\u0026#34;, initialState, reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, incrementByAmount: (state, action: PayloadAction\u0026lt;number\u0026gt;) =\u0026gt; { state.value += action.payload; }, }, }); export const { increment, decrement, incrementByAmount } = counterSlice.actions; export const incrementAsync = (amount: number): AppThunk =\u0026gt; (dispatch) =\u0026gt; { setTimeout(() =\u0026gt; { dispatch(incrementByAmount(amount)); }, 1000); }; export const selectCount = (state: RootState) =\u0026gt; state.counter.value; export default counterSlice.reducer; import React, { useState } from \u0026#34;react\u0026#34;; import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import { decrement, increment, incrementByAmount, incrementAsync, selectCount, } from \u0026#34;./counterSlice\u0026#34;; import styles from \u0026#34;./Counter.module.css\u0026#34;; export function Counter() { const count = useSelector(selectCount); const dispatch = useDispatch(); const [incrementAmount, setIncrementAmount] = useState(\u0026#34;2\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;div className={styles.row}\u0026gt; \u0026lt;button className={styles.button} aria-label=\u0026#34;Increment value\u0026#34; onClick={() =\u0026gt; dispatch(increment())} \u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;span className={styles.value}\u0026gt;{count}\u0026lt;/span\u0026gt; \u0026lt;button className={styles.button} aria-label=\u0026#34;Decrement value\u0026#34; onClick={() =\u0026gt; dispatch(decrement())} \u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={styles.row}\u0026gt; \u0026lt;input className={styles.textbox} aria-label=\u0026#34;Set increment amount\u0026#34; value={incrementAmount} onChange={(e) =\u0026gt; setIncrementAmount(e.target.value)} /\u0026gt; \u0026lt;button className={styles.button} onClick={() =\u0026gt; dispatch(incrementByAmount(Number(incrementAmount) || 0)) } \u0026gt; Add Amount \u0026lt;/button\u0026gt; \u0026lt;button className={styles.asyncButton} onClick={() =\u0026gt; dispatch(incrementAsync(Number(incrementAmount) || 0)) } \u0026gt; Add Async \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } ","permalink":"https://annachengdesu.github.io/post/react/redux/","summary":"Redux 基本概念与 API Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\nStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。\nState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。\nAction 是一个对象。其中的type属性是必须的，表示 Action 的名称。\nAction 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\nReducer 是一个函数，它接受 当前 State 和 Action 作为参数，返回一个新的 State。\nStore 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。\nstore 的三个方法 store.getState() // 获取当前 state store.dispatch() // 派发 action 至 reducer 处理 store.subscribe() // 订阅事件 state 变化即触发 示例代码 实现一个能够添加书籍，并能够根据书籍 ID 删除的功能。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Redux 与 Redux-Toolkit 的实现对比"},{"content":"线上问题描述： 香港某站点登陆后跳转 dashboard 页面，刷新页面后报错 403 Forbidden。\n问题定位： 前端目录文件下有命名为 dashboard 的文件夹，与路由重名 以下为 nginx 部分配置文件代码：\nlocation /entry {\rindex entry.html\r}\rlocation / {\r...\rautoindex on;\rindex index.html;\rtry_files $uri $uri/ /index.html\r} 打开 autoindex，从下图可以得出命中了第二条$uri/规则，但该目录下没有 index.html，nginx 尝试检索目录但是被禁止，所以报错 403。\n为什么刷新后才报错？ 第一次请求是 xxx.com/，命中 index.html，VueRouter 在 history 模式下，login 成功后，借助 history.pushState 实现页面的无刷新跳转到了 /，这种方式改变了 url，之后再根据判断权限点通过 redirect 跳转到对应的页面。如果重新刷新页面会造成一个新的 http 请求，因此会重新请求服务器，如果 nginx 没有匹配到当前 url，就会出现报错页面。\nxxx.com/dashboard，按照 try_files 匹配顺序走到了$uri/，而目录中正好命中了 dashboard 文件夹，然而其中没有 index.html，nginx 尝试检索目录但是被禁止，于是报错 403 Forbidden。\n为什么测试环境没有报错？ 测试环境的 nginx 配置文件代码为：\nlocation / {\r...\rindex index.html;\rtry_files $uri /index.html\r} 永远不会命中 dashboard 文件夹，所以不会有这个问题，但也无法命中其他文件夹下的 index.html 因此 $uri/ 不能移除。\n如何规避该问题？ 在 public 目录下禁止放置与路由重名的文件，资源文件可放置在 src 目录下。\n","permalink":"https://annachengdesu.github.io/post/problem-solved/vue-router-history-fix/","summary":"线上问题描述： 香港某站点登陆后跳转 dashboard 页面，刷新页面后报错 403 Forbidden。\n问题定位： 前端目录文件下有命名为 dashboard 的文件夹，与路由重名 以下为 nginx 部分配置文件代码：\nlocation /entry {\rindex entry.html\r}\rlocation / {\r...\rautoindex on;\rindex index.html;\rtry_files $uri $uri/ /index.html\r} 打开 autoindex，从下图可以得出命中了第二条$uri/规则，但该目录下没有 index.html，nginx 尝试检索目录但是被禁止，所以报错 403。\n为什么刷新后才报错？ 第一次请求是 xxx.com/，命中 index.html，VueRouter 在 history 模式下，login 成功后，借助 history.pushState 实现页面的无刷新跳转到了 /，这种方式改变了 url，之后再根据判断权限点通过 redirect 跳转到对应的页面。如果重新刷新页面会造成一个新的 http 请求，因此会重新请求服务器，如果 nginx 没有匹配到当前 url，就会出现报错页面。\nxxx.com/dashboard，按照 try_files 匹配顺序走到了$uri/，而目录中正好命中了 dashboard 文件夹，然而其中没有 index.html，nginx 尝试检索目录但是被禁止，于是报错 403 Forbidden。\n为什么测试环境没有报错？ 测试环境的 nginx 配置文件代码为：\nlocation / {\r.","title":"记一次线上问题解决-访问页面刷新后报错 403 Forbidden"},{"content":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。\ntype ReturnObj = { increment: () =\u0026gt; number, decrement: () =\u0026gt; number, reset: () =\u0026gt; number, } function createCounter(init: number): ReturnObj { let currentNum = init return { increment: () =\u0026gt; ++currentNum, decrement: () =\u0026gt; --currentNum, reset: () =\u0026gt; { currentNum = init; return currentNum }, } }; DAY4: Apply Transform Over Each Element in Array 题目说明： 返回 arr 经过 fn 处理后的结果，不能使用 Array.map()，可以理解成实现一个类似 Array.map 方法的功能。\n解题思路： 遍历数组的方式除了 Array.map 还有 for、for\u0026hellip;of 与 Array.forEach() 可以用（for\u0026hellip;in 是用在 Object），这几个方法都需要一个额外的变量来储存 fn 执行后的结果。\nfunction map(arr: number[], fn: (n: number, i: number) =\u0026gt; number): number[] { let resultArr: number[] = [] arr.forEach((item, index) =\u0026gt; { resultArr.push(fn(item, index)) }) return resultArr }; 官方解題說明\nhttps://leetcode.com/problems/apply-transform-over-each-element-in-array/editorial/\nDAY5: Filter Elements from Array 题目说明： 仅返回 arr 经过 fn 处理后为真值的元素阵列，不能使用 Array.filter() ，一样可以理解成实作一个类似 Array.filter 方法的功能。\n解题思路： 这题可以看做是DAY4的基础上加上fn执行结构是否为true的判断\n解题代码： type Fn = (n: number, i: number) =\u0026gt; any function filter(arr: number[], fn: Fn): number[] { const newArr: number[] = []; for (let i = 0; i \u0026lt; arr.length; i++) { if (fn(arr[i], i)) newArr.push(arr[i]); } return newArr; }; 官方解题说明 https://leetcode.com/problems/filter-elements-from-array/editorial/\nDAY6：Array Reduce Transformation 题目说明 按照数组 nums 中元素的顺序，从左至右（第一个到最后一个）逐个通过回调函数 fn 处理初始值 init 和每个元素上，最后将数组缩减成单一值后返回。不能使用 Array.reduce()，同样可以理解成实现类似 Array.reduce() 的方法。\n解题方法 由于需要按顺序处理数组中的每个元素，并且每个元素的处理结果都会影响到下一个元素的处理，适合使用循环。在循环中，会需要一个变量来持续追踪当前的处理结果。每次循环结束时，更新这个变量的值，将其设定为当前元素经过缩减函数处理后的结果。这样就能够将前一次循环的结果适当地带入到下一次的处理中。最后循环结束后，只需要返回这个变量的值，即可得到数组经过缩减处理后的结果。\n解题代码： type Fn = (accum: number, curr: number) =\u0026gt; number; function reduce(nums: number[], fn: Fn, init: number): number { let result = init; for (let i = 0; i \u0026lt; nums.length; i++) { result = fn(result, nums[i]); } return result; } 官方解題說明\nhttps://leetcode.com/problems/array-reduce-transformation/editorial/\nDAY7: Function Composition 题目说明 这一题跟昨天的 Array Reduce Function 其实有点像，只是把数组的元素从数字变成函数，可以理解成每次循环使用的回调函数都不同，最后返回的结果虽然变成函数，并且初始值由返回的函数传入的值决定，但函数一样是返回单一值。\n解题方法 尝试解题的时候，发现跟 Array Reduce Function 不一样的地方是，函数组合计算顺序是反过来的。可以看题目的举例 [f(x), g(x), h(x)] 组合后的结果是 fn(x) = f(g(h(x))) 所以是 h(x) 的计算结果传给 g(x) 再传给 f(x)。\n若要将执行顺序反过来，第一个念头是把数组反转，但用 Array.reverse() 会改变原来的数组，需要先复制一个数组再做处理。不过印象中 reverse 性能没那么好，也可以用 for 循环从最后一个当做执行起始点。\n解题代码 type F = (x: number) =\u0026gt; number; function compose(functions: F[]): F { const reversedFns = functions.reverse() return function(x) { let result = x; for (const fn of reversedFns) { result = fn(result); } return result } }; 官方解題說明\nhttps://leetcode.com/problems/function-composition/editorial/\n","permalink":"https://annachengdesu.github.io/post/ts-test-30-days/day1to7/","summary":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。","title":"TypeScript练习题：30天LeetCode挑战（day1 to day7）"},{"content":"防抖 防抖函数原理：把触发非常频繁的事件合并成一次去执行 在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算\n简易手写版： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait) =\u0026gt; { let timer = undefined; // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() =\u0026gt; { func.apply(this, args); }, wait); }; }; 适用场景：\n文本输入的验证，连续输入文字后发送 AJAX 请求进行验证，验证一次就好 按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似 节流 节流函数原理:指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。总结起来就是：事件按照一段时间的间隔来进行触发。\n简易手写版： 时间戳实现\nconst throttle = (func, wait = 50) =\u0026gt; { let lastTime = 0; return function (...args) { let now = Date.now(); // 将当前时间和上一次执行函数时间对比 // 如果差值大于设置的等待时间就执行函数 if (now - lastTime \u0026gt; wait) { lastTime = now; func.apply(this, args); } }; }; 定时器实现\nfunction throttle(func, delay) { var timer = 0; return function () { var context = this; var args = arguments; if (timer) return; // 当前有任务了，直接返回 timer = setTimeout(function () { func.apply(context, args); timer = 0; }, delay); }; } 适用场景：\n拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动。DOM 元素的拖拽功能实现（mousemove） 缩放场景：监控浏览器resize 滚动场景：监听滚动scroll事件判断是否到页面底部自动加载更多 动画场景：避免短时间内多次触发动画引起性能问题 总结 函数防抖：\n限制执行次数，多次密集的触发只执行一次 将几次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：\n限制执行的频率，按照一定的时间间隔有节奏的执行 使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 ","permalink":"https://annachengdesu.github.io/post/javascript/debounce-and-throttle/","summary":"防抖 防抖函数原理：把触发非常频繁的事件合并成一次去执行 在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算\n简易手写版： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait) =\u0026gt; { let timer = undefined; // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() =\u0026gt; { func.apply(this, args); }, wait); }; }; 适用场景：\n文本输入的验证，连续输入文字后发送 AJAX 请求进行验证，验证一次就好 按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似 节流 节流函数原理:指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。总结起来就是：事件按照一段时间的间隔来进行触发。\n简易手写版： 时间戳实现\nconst throttle = (func, wait = 50) =\u0026gt; { let lastTime = 0; return function (...args) { let now = Date.","title":"一句话概括防抖和节流的区别"},{"content":"通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34;, }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。\n缺点 在 JavaScript 中，工厂模式只不过是一个不使用 new 关键字返回对象的函数。 ES6 箭头函数允许我们创建每次隐式返回一个对象的小型工厂函数。\n然而，在许多情况下，每次创建新实例而不是新对象可能会更有效地存储内存。\nclass User { constructor(firstName, lastName, email) { this.firstName = firstName; this.lastName = lastName; this.email = email; } fullName() { return `${this.firstName} ${this.lastName}`; } } const user1 = new User({ firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;john@doe.com\u0026#34;, }); const user2 = new User({ firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;jane@doe.com\u0026#34;, }); ","permalink":"https://annachengdesu.github.io/post/patterns/factory/","summary":"通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34;, }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。","title":"02-Factory Pattern 工厂模式-vanilla篇"}]