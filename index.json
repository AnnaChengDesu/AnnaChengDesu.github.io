[{"content":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。\ntype ReturnObj = { increment: () =\u0026gt; number, decrement: () =\u0026gt; number, reset: () =\u0026gt; number, } function createCounter(init: number): ReturnObj { let currentNum = init return { increment: () =\u0026gt; ++currentNum, decrement: () =\u0026gt; --currentNum, reset: () =\u0026gt; { currentNum = init; return currentNum }, } }; DAY4: Apply Transform Over Each Element in Array 题目说明： 返回 arr 经过 fn 处理后的结果，不能使用 Array.map()，可以理解成实现一个类似 Array.map 方法的功能。\n解题思路： 遍历数组的方式除了 Array.map 还有 for、for\u0026hellip;of 与 Array.forEach() 可以用（for\u0026hellip;in 是用在 Object），这几个方法都需要一个额外的变量来储存 fn 执行后的结果。\nfunction map(arr: number[], fn: (n: number, i: number) =\u0026gt; number): number[] { let resultArr: number[] = [] arr.forEach((item, index) =\u0026gt; { resultArr.push(fn(item, index)) }) return resultArr }; 官方解題說明\nhttps://leetcode.com/problems/apply-transform-over-each-element-in-array/editorial/\nDAY5: Filter Elements from Array 题目说明： 仅返回 arr 经过 fn 处理后为真值的元素阵列，不能使用 Array.filter() ，一样可以理解成实作一个类似 Array.filter 方法的功能。\n解题思路： 这题可以看做是DAY4的基础上加上fn执行结构是否为true的判断\n解题代码： type Fn = (n: number, i: number) =\u0026gt; any function filter(arr: number[], fn: Fn): number[] { const newArr: number[] = []; for (let i = 0; i \u0026lt; arr.length; i++) { if (fn(arr[i], i)) newArr.push(arr[i]); } return newArr; }; 官方解题说明 https://leetcode.com/problems/filter-elements-from-array/editorial/\nDAY6：Array Reduce Transformation 题目说明 按照数组 nums 中元素的顺序，从左至右（第一个到最后一个）逐个通过回调函数 fn 处理初始值 init 和每个元素上，最后将数组缩减成单一值后返回。不能使用 Array.reduce()，同样可以理解成实现类似 Array.reduce() 的方法。\n解题方法 由于需要按顺序处理数组中的每个元素，并且每个元素的处理结果都会影响到下一个元素的处理，适合使用循环。在循环中，会需要一个变量来持续追踪当前的处理结果。每次循环结束时，更新这个变量的值，将其设定为当前元素经过缩减函数处理后的结果。这样就能够将前一次循环的结果适当地带入到下一次的处理中。最后循环结束后，只需要返回这个变量的值，即可得到数组经过缩减处理后的结果。\n解题代码： type Fn = (accum: number, curr: number) =\u0026gt; number; function reduce(nums: number[], fn: Fn, init: number): number { let result = init; for (let i = 0; i \u0026lt; nums.length; i++) { result = fn(result, nums[i]); } return result; } 官方解題說明\nhttps://leetcode.com/problems/array-reduce-transformation/editorial/\nDAY7: Function Composition 题目说明 这一题跟昨天的 Array Reduce Function 其实有点像，只是把数组的元素从数字变成函数，可以理解成每次循环使用的回调函数都不同，最后返回的结果虽然变成函数，并且初始值由返回的函数传入的值决定，但函数一样是返回单一值。\n解题方法 尝试解题的时候，发现跟 Array Reduce Function 不一样的地方是，函数组合计算顺序是反过来的。可以看题目的举例 [f(x), g(x), h(x)] 组合后的结果是 fn(x) = f(g(h(x))) 所以是 h(x) 的计算结果传给 g(x) 再传给 f(x)。\n若要将执行顺序反过来，第一个念头是把数组反转，但用 Array.reverse() 会改变原来的数组，需要先复制一个数组再做处理。不过印象中 reverse 性能没那么好，也可以用 for 循环从最后一个当做执行起始点。\n解题代码 type F = (x: number) =\u0026gt; number; function compose(functions: F[]): F { const reversedFns = functions.reverse() return function(x) { let result = x; for (const fn of reversedFns) { result = fn(result); } return result } }; 官方解題說明\nhttps://leetcode.com/problems/function-composition/editorial/\n","permalink":"https://annachengdesu.github.io/post/ts-test-30-days/day1to7/","summary":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。","title":"TypeScript练习题：30天LeetCode挑战（day1 to day7）"},{"content":"Command Pattern 命令模式 使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。\n让我们重构 OrderManager 类：它不再具有 placeOrder 、 cancelOrder 和 trackOrder 方法，而是只有一个方法： execute 。该方法将执行它给出的任何命令。\nclass OrderManager { constructor() { this.orders = []; } execute(command, ...args) { return command.execute(this.orders, ...args); } } 还需要为订单管理器创建三个 Command ：\nclass Command { constructor(execute) { this.execute = execute; } } function PlaceOrderCommand(order, id) { return new Command((orders) =\u0026gt; { orders.push(id); return `You have successfully ordered ${order} (${id})`; }); } function CancelOrderCommand(id) { return new Command((orders) =\u0026gt; { orders = orders.filter((order) =\u0026gt; order.id !== id); return `You have canceled your order ${id}`; }); } function TrackOrderCommand(id) { return new Command(() =\u0026gt; `Your order ${id} will arrive in 20 minutes.`); } const manager = new OrderManager(); manager.execute(new PlaceOrderCommand(\u0026#34;noodle\u0026#34;, \u0026#34;1234\u0026#34;)); manager.execute(new TrackOrderCommand(\u0026#34;1234\u0026#34;)); manager.execute(new CancelOrderCommand(\u0026#34;1234\u0026#34;)); 这些方法不再直接耦合到 OrderManager 实例，而是现在是独立的解耦函数，我们可以通过 OrderManager 方法调用它们。\n优点 命令模式允许我们将方法从执行操作的对象中解耦。它使得你能够更加灵活的控制，比如一些具有生命周期的命令，又或者需要在特定时间排队并执行的命令。\n缺点 命令模式的用例非常有限，并且经常向应用程序添加不必要的样板。\n","permalink":"https://annachengdesu.github.io/post/patterns/command-pattern/","summary":"Command Pattern 命令模式 使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。","title":"01-Command Pattern-设计模式学习-vanilla篇"},{"content":"Factory Pattern 工厂模式 通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34; }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。\n缺点 在 JavaScript 中，工厂模式只不过是一个不使用 new 关键字返回对象的函数。 ES6 箭头函数允许我们创建每次隐式返回一个对象的小型工厂函数。\n然而，在许多情况下，每次创建新实例而不是新对象可能会更有效地存储内存。\nclass User { constructor(firstName, lastName, email) { this.firstName = firstName; this.lastName = lastName; this.email = email; } fullName() { return `${this.firstName} ${this.lastName}`; } } const user1 = new User({ firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;john@doe.com\u0026#34;, }); const user2 = new User({ firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;jane@doe.com\u0026#34;, }); ","permalink":"https://annachengdesu.github.io/post/patterns/factory-pattern/","summary":"Factory Pattern 工厂模式 通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34; }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。","title":"02-Factory Pattern-设计模式学习-vanilla篇"},{"content":"Mediator/Middleware Pattern 中介者/中间件模式 中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在Javascript中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.send(\u0026#34;Hi there!\u0026#34;); user2.send(\u0026#34;Hey!\u0026#34;); 案例分析 Express.js 是一种流行的 Web 应用程序服务器框架。我们可以向用户可以访问的某些路由添加回调。\n假设如果用户点击根路径 '/' ，我们希望向请求添加一个标头。我们可以在中间件回调中添加此标头。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use(\u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }); next 方法调用请求-响应周期中的下一个回调。我们将有效地创建位于请求和响应之间的中间件功能链，反之亦然。\n让我们添加另一个中间件函数来检查 test-header 是否已正确添加。之前的中间件功能添加的更改将在整个链中可见。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use( \u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }, (req, res, next) =\u0026gt; { console.log(`Request has test header: ${!!req.headers[\u0026#34;test-header\u0026#34;]}`); next(); } ); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;); res.send(Buffer.from(html)); }); app.listen(8080, function() { console.log(\u0026#34;Server is running on 8080\u0026#34;); }); 我们可以通过一个或多个中间件函数跟踪和修改请求对象一直到响应。\n每次用户点击根端点 '/' 时，都会调用两个中间件回调。\n总结 中间件模式让所有通信都流经一个中心点，使我们能够轻松简化对象之间的多对多关系。\n","permalink":"https://annachengdesu.github.io/post/patterns/mediator-pattern/","summary":"Mediator/Middleware Pattern 中介者/中间件模式 中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在Javascript中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.","title":"03-Mediator/Middleware Pattern-设计模式学习-vanilla篇"}]