[{"content":"Observer Pattern 观察者模式 通过观察者模式，我们可以将某些对象（观察者）订阅到另一个称为可观察对象的对象。每当事件发生时，可观察者都会通知其所有观察者。\n一个可观察对象通常包含 3 个重要部分：\nobservers ：观察者数组，每当特定事件发生时都会收到通知\nsubscribe() ：将观察者添加到观察者列表的方法\nunsubscribe() ：从观察者列表中删除观察者的方法\nnotify() ：每当特定事件发生时通知所有观察者的方法\n创建一个简单的方法是使用 ES6 类。\nclass Observable { constructor() { this.observers = []; } subscribe(func) { this.observers.push(func); } unsubscribe(func) { this.observers = this.observers.filter((observer) =\u0026gt; observer !== func); } notify(data) { this.observers.forEach((observer) =\u0026gt; observer(data)); } } 我们现在可以使用 subscribe 方法将观察者添加到观察者列表中，使用 unsubscribe 方法删除观察者，并使用 notify 方法通知所有订阅者。\n现在我们有一个非常基本的应用程序，仅包含两个组件： Button 和 Switch 。\nexport default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt; ); } 我们希望跟踪用户与应用程序的交互。每当用户单击按钮或切换开关时，我们都希望使用时间戳记录此事件。除了记录之外，我们还想创建一个 Toast 通知，每当事件发生时就会显示。\n每当用户调用 handleClick 或 handleToggle 函数时，这些函数都会调用观察者上的 notify 方法。 notify 方法用 handleClick 或 handleToggle 函数传递的数据通知所有订阅者。\n首先，让我们创建 logger 和 toastify 函数。这些函数最终将从 notify 方法接收 data 。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data); } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 目前， logger 和 toastify 函数不知道observable，observable还无法通知它们。为了使它们成为观察者，我们必须使用可观察对象上的 subscribe 方法来订阅它们。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data); } observable.subscribe(logger); observable.subscribe(toastify); export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 每当事件发生时， logger 和 toastify 函数都会收到通知。现在我们只需要实现实际通知可观察对象的函数： handleClick 和 handleToggle 函数。这些函数应该调用可观察对象的 notify 方法，并传递观察者应该接收的数据。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()} ${data}`); } function toastify(data) { toast(data, { position: toast.POSITION.BOTTOM_RIGHT, closeButton: false, autoClose: 2000 }); } function handleClick() { observable.notify(\u0026#34;User clicked button!\u0026#34;); } function handleToggle() { observable.notify(\u0026#34;User toggled switch!\u0026#34;); } observable.subscribe(logger); observable.subscribe(toastify); export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button variant=\u0026#34;contained\u0026#34; onClick={handleClick}\u0026gt; Click me! \u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch name=\u0026#34;\u0026#34; onChange={handleToggle} /\u0026gt;} label=\u0026#34;Toggle me!\u0026#34; /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } 我们刚刚完成了整个流程： handleClick 和 handleToggle 用数据调用观察者上的 notify 方法，之后观察者通知订阅者： logger 和 toastify 在这种情况下起作用。\n每当用户与任一组件交互时， logger 和 toastify 函数都会收到我们传递给 notify 方法的数据的通知。\n我们可以通过多种方式使用观察者模式，它在处理异步、基于事件的数据时非常有用。当你希望每在某些数据下载完成时，或者每当用户向留言板发送新消息时，某些组件都会收到通知，并且所有其他成员都应该收到通知。\n案例分析 使用可观察模式的流行库有 RxJS。\nReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events. - RxJS\n使用 RxJS，我们可以创建可观察对象并订阅某些事件。让我们看一下他们的文档中包含的一个示例，该示例记录用户是否在文档中拖动。\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import { fromEvent, merge } from \u0026#34;rxjs\u0026#34;; import { sample, mapTo } from \u0026#34;rxjs/operators\u0026#34;; import \u0026#34;./styles.css\u0026#34;; merge( fromEvent(document, \u0026#34;mousedown\u0026#34;).pipe(mapTo(false)), fromEvent(document, \u0026#34;mousemove\u0026#34;).pipe(mapTo(true)) ) .pipe(sample(fromEvent(document, \u0026#34;mouseup\u0026#34;))) .subscribe(isDragging =\u0026gt; { console.log(\u0026#34;Were you dragging?\u0026#34;, isDragging); }); ReactDOM.render( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;Click or drag anywhere and check the console!\u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); RxJS 具有大量与可观察模式配合使用的内置功能和示例。\n优点 使用观察者模式是强制关注点分离和单一职责原则的好方法。观察者对象与可观察对象并不紧密耦合，并且可以随时解耦。可观察对象负责监视事件，而观察者只处理接收到的数据。\n缺点 如果观察者变得过于复杂，则在通知所有订阅者时可能会导致性能问题。\n","permalink":"https://annachengdesu.github.io/post/patterns/observer-pattern/","summary":"Observer Pattern 观察者模式 通过观察者模式，我们可以将某些对象（观察者）订阅到另一个称为可观察对象的对象。每当事件发生时，可观察者都会通知其所有观察者。\n一个可观察对象通常包含 3 个重要部分：\nobservers ：观察者数组，每当特定事件发生时都会收到通知\nsubscribe() ：将观察者添加到观察者列表的方法\nunsubscribe() ：从观察者列表中删除观察者的方法\nnotify() ：每当特定事件发生时通知所有观察者的方法\n创建一个简单的方法是使用 ES6 类。\nclass Observable { constructor() { this.observers = []; } subscribe(func) { this.observers.push(func); } unsubscribe(func) { this.observers = this.observers.filter((observer) =\u0026gt; observer !== func); } notify(data) { this.observers.forEach((observer) =\u0026gt; observer(data)); } } 我们现在可以使用 subscribe 方法将观察者添加到观察者列表中，使用 unsubscribe 方法删除观察者，并使用 notify 方法通知所有订阅者。\n现在我们有一个非常基本的应用程序，仅包含两个组件： Button 和 Switch 。\nexport default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!","title":"05-Observer Pattern-设计模式学习-vanilla篇"},{"content":"Mediator/Middleware Pattern 中介者/中间件模式 中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在 Javascript 中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.send(\u0026#34;Hi there!\u0026#34;); user2.send(\u0026#34;Hey!\u0026#34;); 案例分析 Express.js 是一种流行的 Web 应用程序服务器框架。我们可以向用户可以访问的某些路由添加回调。\n假设如果用户点击根路径 '/' ，我们希望向请求添加一个标头。我们可以在中间件回调中添加此标头。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use(\u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }); next 方法调用请求-响应周期中的下一个回调。我们将有效地创建位于请求和响应之间的中间件功能链，反之亦然。\n让我们添加另一个中间件函数来检查 test-header 是否已正确添加。之前的中间件功能添加的更改将在整个链中可见。\nconst app = require(\u0026#34;express\u0026#34;)(); app.use( \u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }, (req, res, next) =\u0026gt; { console.log(`Request has test header: ${!!req.headers[\u0026#34;test-header\u0026#34;]}`); next(); } ); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;); res.send(Buffer.from(html)); }); app.listen(8080, function () { console.log(\u0026#34;Server is running on 8080\u0026#34;); }); 我们可以通过一个或多个中间件函数跟踪和修改请求对象一直到响应。\n每次用户点击根端点 '/' 时，都会调用两个中间件回调。\n总结 中间件模式让所有通信都流经一个中心点，使我们能够轻松简化对象之间的多对多关系。\n","permalink":"https://annachengdesu.github.io/post/patterns/mediator-pattern/","summary":"Mediator/Middleware Pattern 中介者/中间件模式 中介者模式使组件可以通过一个中心点（中介者）相互交互。中介者不是直接相互交谈，而是接收请求并将其转发。在 JavaScript 中，中介者通常只不过是一个对象文字或一个函数。\n可以将此模式与空中交通管制员和飞行员之间的关系进行比较。飞行员之间不会直接相互交谈（这可能会导致混乱），而是与空中交通管制员交谈。空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n在 Javascript 中，我们经常需要处理对象之间的多向数据。项目中如果有大量组件，组件之间的通信很可能会变得相当混乱。\n对象的请求由中介处理，而不是让每个对象直接与其他对象对话，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。\n调解者模式的一个很好的用例是聊天室。聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。\nclass ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time} [${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatroom.logMessage(this, message); } } 我们可以创建连接到聊天室的新用户。每个用户实例都有一个 send 方法，我们可以使用它来发送消息。\nconst chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.","title":"03-Mediator/Middleware Pattern-设计模式学习-vanilla篇"},{"content":"Mixin Pattern 混合模式 mixin 是一个对象，我们可以使用它向另一个对象或类添加可重用的功能，而无需使用继承。我们不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类添加功能。\n假设我们的应用程序需要创建多只狗。然而，我们创建的基本狗除了 name 属性之外没有任何属性。\nclass Dog { constructor(name) { this.name = name; } } 狗应该能够做的不仅仅是有名字。它应该能够吠叫、摇尾巴和玩耍！我们可以创建一个 mixin 来为我们提供 bark 、 wagTail 和 play 属性，而不是直接将其添加到 Dog 中。\nconst dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; 我们可以使用 Object.assign 方法将 dogFunctionality mixin 添加到 Dog 原型中。此方法允许我们向目标对象添加属性：在本例中为 Dog.prototype 。 Dog 的每个新实例都可以访问 dogFunctionality 的属性，因为它们被添加到 Dog 的原型中。\nclass Dog { constructor(name) { this.name = name; } } const dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; Object.assign(Dog.prototype, dogFunctionality); 让我们创建我们的第一个宠物 pet1 ，名为 Daisy。由于我们刚刚将 dogFunctionality mixin 添加到 Dog 的原型中，Daisy 应该能够走路、摇尾巴和玩耍！\nconst pet1 = new Dog(\u0026#34;Daisy\u0026#34;); pet1.name; // Daisy pet1.bark(); // Woof! pet1.play(); // Playing! Mixins 使我们可以轻松地向类或对象添加自定义功能，而无需使用继承。\n虽然我们可以使用 mixins 添加功能而无需继承，但 mixins 本身可以使用继承。大多数哺乳动物（除了海豚……也许还有更多）也可以行走和睡眠。狗是哺乳动物，应该能够行走和睡觉。\n让我们创建一个添加 walk 和 sleep 属性的 animalFunctionality mixin。\nconst animalFunctionality = { walk: () =\u0026gt; console.log(\u0026#34;Walking!\u0026#34;), sleep: () =\u0026gt; console.log(\u0026#34;Sleeping!\u0026#34;), }; 我们可以使用 Object.assign 将这些属性添加到 dogFunctionality 原型中。在本例中，目标对象是 dogFunctionality 。\nconst animalFunctionality = { walk: () =\u0026gt; console.log(\u0026#34;Walking!\u0026#34;), sleep: () =\u0026gt; console.log(\u0026#34;Sleeping!\u0026#34;), }; const dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), walk() { super.walk(); }, sleep() { super.sleep(); }, }; Object.assign(dogFunctionality, animalFunctionality); Object.assign(Dog.prototype, dogFunctionality); 现在Dog 的任何新实例现在也可以访问 walk 和 sleep 方法。\nconst pet1 = new Dog(\u0026#34;Daisy\u0026#34;); console.log(pet1.name); pet1.bark(); pet1.play(); pet1.walk(); pet1.sleep(); 现实世界中 mixin 的示例在浏览器环境中的 Window 界面上可见。 Window 对象实现了许多如 WindowOrWorkerGlobalScope 和 WindowEventHandlers的 mixin 属性，这使得我们能够访问 setTimeout 等属性和 setInterval 、 indexedDB 和 isSecureContext 。\n由于它是一个 mixin，因此仅用于向对象添加功能，因此您将无法创建 WindowOrWorkerGlobalScope 类型的对象。\nwindow.indexedDB.open(\u0026#34;toDoList\u0026#34;); window.addEventListener(\u0026#34;beforeunload\u0026#34;, event =\u0026gt; { event.preventDefault(); event.returnValue = \u0026#34;\u0026#34;; }); window.onbeforeunload = function() { console.log(\u0026#34;Unloading!\u0026#34;); }; console.log( \u0026#34;From WindowEventHandlers mixin: onbeforeunload\u0026#34;, window.onbeforeunload ); console.log( \u0026#34;From WindowOrWorkerGlobalScope mixin: isSecureContext\u0026#34;, window.isSecureContext ); console.log( \u0026#34;WindowEventHandlers itself is undefined\u0026#34;, window.WindowEventHandlers ); console.log( \u0026#34;WindowOrWorkerGlobalScope itself is undefined\u0026#34;, window.WindowOrWorkerGlobalScope ); React (pre ES6) 在引入 ES6 类之前，Mixin 通常用于向 React 组件添加功能。 React 团队不鼓励使用 mixins，因为它很容易给组件增加不必要的复杂性，使其难以维护和重用。 React 团队鼓励使用更高阶的组件，现在这些组件通常可以被 Hook 取代。\nMixins 允许我们通过将功能注入到对象的原型中，轻松地向对象添加功能，而无需继承。修改对象的原型被认为是不好的做法，因为它可能导致原型污染以及函数起源的一定程度的不确定性。\n","permalink":"https://annachengdesu.github.io/post/patterns/minin-pattern/","summary":"Mixin Pattern 混合模式 mixin 是一个对象，我们可以使用它向另一个对象或类添加可重用的功能，而无需使用继承。我们不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类添加功能。\n假设我们的应用程序需要创建多只狗。然而，我们创建的基本狗除了 name 属性之外没有任何属性。\nclass Dog { constructor(name) { this.name = name; } } 狗应该能够做的不仅仅是有名字。它应该能够吠叫、摇尾巴和玩耍！我们可以创建一个 mixin 来为我们提供 bark 、 wagTail 和 play 属性，而不是直接将其添加到 Dog 中。\nconst dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), }; 我们可以使用 Object.assign 方法将 dogFunctionality mixin 添加到 Dog 原型中。此方法允许我们向目标对象添加属性：在本例中为 Dog.prototype 。 Dog 的每个新实例都可以访问 dogFunctionality 的属性，因为它们被添加到 Dog 的原型中。\nclass Dog { constructor(name) { this.","title":"04-Mixin Pattern-设计模式学习-vanilla篇"},{"content":"Factory Pattern 工厂模式 通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34;, }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。\n缺点 在 JavaScript 中，工厂模式只不过是一个不使用 new 关键字返回对象的函数。 ES6 箭头函数允许我们创建每次隐式返回一个对象的小型工厂函数。\n然而，在许多情况下，每次创建新实例而不是新对象可能会更有效地存储内存。\nclass User { constructor(firstName, lastName, email) { this.firstName = firstName; this.lastName = lastName; this.email = email; } fullName() { return `${this.firstName} ${this.lastName}`; } } const user1 = new User({ firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;john@doe.com\u0026#34;, }); const user2 = new User({ firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;jane@doe.com\u0026#34;, }); ","permalink":"https://annachengdesu.github.io/post/patterns/factory-pattern/","summary":"Factory Pattern 工厂模式 通过工厂模式，我们可以使用工厂函数来创建新对象。当一个函数不使用 new 关键字来返回一个新对象时，它就是一个工厂函数。\n假设我们的应用程序需要许多用户。我们可以使用 firstName 、 lastName 和 email 属性创建新用户。工厂函数还将 fullName 属性添加到新创建的对象中，该属性返回 firstName 和 lastName 。\nconst createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName} ${this.lastName}`; }, }); 现在我们可以通过调用 createUser 函数轻松创建多个用户。\nconst user1 = createUser({ firstName: \u0026#34;Anna\u0026#34;, lastName: \u0026#34;Cheng\u0026#34;, email: \u0026#34;AnnaCheng@gmail.com\u0026#34;, }); 如果我们要创建相对复杂且可配置的对象，工厂模式会很有用。键和值的值可能取决于特定的环境或配置。使用工厂模式，我们可以轻松创建包含自定义键和值的新对象。\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({ [key]: value, }); createObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } 优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。","title":"02-Factory Pattern-设计模式学习-vanilla篇"},{"content":"Command Pattern 命令模式 使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。\n让我们重构 OrderManager 类：它不再具有 placeOrder 、 cancelOrder 和 trackOrder 方法，而是只有一个方法： execute 。该方法将执行它给出的任何命令。\nclass OrderManager { constructor() { this.orders = []; } execute(command, ...args) { return command.execute(this.orders, ...args); } } 还需要为订单管理器创建三个 Command ：\nclass Command { constructor(execute) { this.execute = execute; } } function PlaceOrderCommand(order, id) { return new Command((orders) =\u0026gt; { orders.push(id); return `You have successfully ordered ${order} (${id})`; }); } function CancelOrderCommand(id) { return new Command((orders) =\u0026gt; { orders = orders.filter((order) =\u0026gt; order.id !== id); return `You have canceled your order ${id}`; }); } function TrackOrderCommand(id) { return new Command(() =\u0026gt; `Your order ${id} will arrive in 20 minutes.`); } const manager = new OrderManager(); manager.execute(new PlaceOrderCommand(\u0026#34;noodle\u0026#34;, \u0026#34;1234\u0026#34;)); manager.execute(new TrackOrderCommand(\u0026#34;1234\u0026#34;)); manager.execute(new CancelOrderCommand(\u0026#34;1234\u0026#34;)); 这些方法不再直接耦合到 OrderManager 实例，而是现在是独立的解耦函数，我们可以通过 OrderManager 方法调用它们。\n优点 命令模式允许我们将方法从执行操作的对象中解耦。它使得你能够更加灵活的控制，比如一些具有生命周期的命令，又或者需要在特定时间排队并执行的命令。\n缺点 命令模式的用例非常有限，并且经常向应用程序添加不必要的样板。\n","permalink":"https://annachengdesu.github.io/post/patterns/command-pattern/","summary":"Command Pattern 命令模式 使用命令模式，可以将执行某个任务的对象与调用该方法的对象解耦。\n假设有一个外卖配送平台。用户可以下单、跟踪和取消订单。\nclass OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `You have successfully ordered ${order} (${id})`; } trackOrder(id) { return `Your order ${id} will arrive in 20 minutes.` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `You have canceled your order ${id}` } } 在 OrderManager 类上，可以访问 placeOrder 、 trackOrder 和 cancelOrder 方法。直接使用这些方法将是完全可行的。\n但是，直接在 manager 实例上调用方法也有缺点。我们可能会决定稍后重命名某些方法，或者改变某些方法的功能。\n假设现在将其重命名为 addOrder ，而不是 placeOrder ，这意味着我们必须确保代码库中的没有任何位置调用 placeOrder 方法，这种场景在大型应用程序中可能非常棘手。相反，我们希望将方法与 manager 对象解耦，并为每个命令创建单独的命令函数。","title":"01-Command Pattern-设计模式学习-vanilla篇"},{"content":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。\ntype ReturnObj = { increment: () =\u0026gt; number, decrement: () =\u0026gt; number, reset: () =\u0026gt; number, } function createCounter(init: number): ReturnObj { let currentNum = init return { increment: () =\u0026gt; ++currentNum, decrement: () =\u0026gt; --currentNum, reset: () =\u0026gt; { currentNum = init; return currentNum }, } }; DAY4: Apply Transform Over Each Element in Array 题目说明： 返回 arr 经过 fn 处理后的结果，不能使用 Array.map()，可以理解成实现一个类似 Array.map 方法的功能。\n解题思路： 遍历数组的方式除了 Array.map 还有 for、for\u0026hellip;of 与 Array.forEach() 可以用（for\u0026hellip;in 是用在 Object），这几个方法都需要一个额外的变量来储存 fn 执行后的结果。\nfunction map(arr: number[], fn: (n: number, i: number) =\u0026gt; number): number[] { let resultArr: number[] = [] arr.forEach((item, index) =\u0026gt; { resultArr.push(fn(item, index)) }) return resultArr }; 官方解題說明\nhttps://leetcode.com/problems/apply-transform-over-each-element-in-array/editorial/\nDAY5: Filter Elements from Array 题目说明： 仅返回 arr 经过 fn 处理后为真值的元素阵列，不能使用 Array.filter() ，一样可以理解成实作一个类似 Array.filter 方法的功能。\n解题思路： 这题可以看做是DAY4的基础上加上fn执行结构是否为true的判断\n解题代码： type Fn = (n: number, i: number) =\u0026gt; any function filter(arr: number[], fn: Fn): number[] { const newArr: number[] = []; for (let i = 0; i \u0026lt; arr.length; i++) { if (fn(arr[i], i)) newArr.push(arr[i]); } return newArr; }; 官方解题说明 https://leetcode.com/problems/filter-elements-from-array/editorial/\nDAY6：Array Reduce Transformation 题目说明 按照数组 nums 中元素的顺序，从左至右（第一个到最后一个）逐个通过回调函数 fn 处理初始值 init 和每个元素上，最后将数组缩减成单一值后返回。不能使用 Array.reduce()，同样可以理解成实现类似 Array.reduce() 的方法。\n解题方法 由于需要按顺序处理数组中的每个元素，并且每个元素的处理结果都会影响到下一个元素的处理，适合使用循环。在循环中，会需要一个变量来持续追踪当前的处理结果。每次循环结束时，更新这个变量的值，将其设定为当前元素经过缩减函数处理后的结果。这样就能够将前一次循环的结果适当地带入到下一次的处理中。最后循环结束后，只需要返回这个变量的值，即可得到数组经过缩减处理后的结果。\n解题代码： type Fn = (accum: number, curr: number) =\u0026gt; number; function reduce(nums: number[], fn: Fn, init: number): number { let result = init; for (let i = 0; i \u0026lt; nums.length; i++) { result = fn(result, nums[i]); } return result; } 官方解題說明\nhttps://leetcode.com/problems/array-reduce-transformation/editorial/\nDAY7: Function Composition 题目说明 这一题跟昨天的 Array Reduce Function 其实有点像，只是把数组的元素从数字变成函数，可以理解成每次循环使用的回调函数都不同，最后返回的结果虽然变成函数，并且初始值由返回的函数传入的值决定，但函数一样是返回单一值。\n解题方法 尝试解题的时候，发现跟 Array Reduce Function 不一样的地方是，函数组合计算顺序是反过来的。可以看题目的举例 [f(x), g(x), h(x)] 组合后的结果是 fn(x) = f(g(h(x))) 所以是 h(x) 的计算结果传给 g(x) 再传给 f(x)。\n若要将执行顺序反过来，第一个念头是把数组反转，但用 Array.reverse() 会改变原来的数组，需要先复制一个数组再做处理。不过印象中 reverse 性能没那么好，也可以用 for 循环从最后一个当做执行起始点。\n解题代码 type F = (x: number) =\u0026gt; number; function compose(functions: F[]): F { const reversedFns = functions.reverse() return function(x) { let result = x; for (const fn of reversedFns) { result = fn(result); } return result } }; 官方解題說明\nhttps://leetcode.com/problems/function-composition/editorial/\n","permalink":"https://annachengdesu.github.io/post/ts-test-30-days/day1to7/","summary":"LeetCode 挑战题目汇总地址： 30 Days of JavaScript Challenge\nDAY1: Create Hello World Function 解题代码： function createHelloWorld() { return function(...args): string { return \u0026#34;Hello World\u0026#34; }; }; 官方解題說明\nhttps://leetcode.com/problems/create-hello-world-function/editorial/\nDAY2: Counter 题目说明： 第一次调用 createCounter 传值 n, 后面每次调用返回都比前一次返回的值加1。\n解题思路： 可以用变量和运算符的相对位置来记递增运算符返回的值是计算前还是计算后的值：n++ 的 n 放在 ++ 的前面，所以是运算前的值；++n 是放在 ++ 的后面，所以是运算后的值。\nfunction createCounter(n: number): () =\u0026gt; number { return function() { return n++ } } 官方解題說明\nhttps://leetcode.com/problems/counter/editorial/\nDAY3: Counter II 题目说明： 实现函数 createCounter，可以传一个初始值参数，返回包含三个函数的对象，三个函数分别是 increment()、decrement()、reset()。\n解题思路： increment()、decrement() 都是返回计算过后的值，变量要放在运算符的后面。reset() 重置初始值，需要额外用变量储存当前计算值，保留初始值 init。","title":"TypeScript练习题：30天LeetCode挑战（day1 to day7）"}]