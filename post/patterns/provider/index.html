<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>09-Provider Pattern 提供者模式-vanilla篇 | Anna.me</title><meta name=keywords content="Javascript"><meta name=description content="在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。
我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。
假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。
function App() { const data = { ... } return ( <div> <SideBar data={data} /> <Content data={data} /> </div> ) } const SideBar = ({ data }) => <List data={data} /> const List = ({ data }) => <ListItem data={data} /> const ListItem = ({ data }) => <span>{data."><meta name=author content="Anna.me"><link rel=canonical href=https://annachengdesu.github.io/post/patterns/provider/><link crossorigin=anonymous href=/assets/css/stylesheet.f2da42eb72c6ac4b82b92c21716a96ae77ab6a2505a713280483eee56482a913.css integrity="sha256-8tpC63LGrEuCuSwhcWqWrneraiUFpxMoBIPu5WSCqRM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://annachengdesu.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="09-Provider Pattern 提供者模式-vanilla篇"><meta property="og:description" content="在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。
我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。
假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。
function App() { const data = { ... } return ( <div> <SideBar data={data} /> <Content data={data} /> </div> ) } const SideBar = ({ data }) => <List data={data} /> const List = ({ data }) => <ListItem data={data} /> const ListItem = ({ data }) => <span>{data."><meta property="og:type" content="article"><meta property="og:url" content="https://annachengdesu.github.io/post/patterns/provider/"><meta property="og:image" content="https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-08-20T20:06:34+08:00"><meta property="article:modified_time" content="2023-08-20T20:06:34+08:00"><meta property="og:site_name" content="Anna.me"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="09-Provider Pattern 提供者模式-vanilla篇"><meta name=twitter:description content="在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。
我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。
假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。
function App() { const data = { ... } return ( <div> <SideBar data={data} /> <Content data={data} /> </div> ) } const SideBar = ({ data }) => <List data={data} /> const List = ({ data }) => <ListItem data={data} /> const ListItem = ({ data }) => <span>{data."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://annachengdesu.github.io/post/"},{"@type":"ListItem","position":2,"name":"09-Provider Pattern 提供者模式-vanilla篇","item":"https://annachengdesu.github.io/post/patterns/provider/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"09-Provider Pattern 提供者模式-vanilla篇","name":"09-Provider Pattern 提供者模式-vanilla篇","description":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。\n我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。\n假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。\nfunction App() { const data = { ... } return ( \u0026lt;div\u0026gt; \u0026lt;SideBar data={data} /\u0026gt; \u0026lt;Content data={data} /\u0026gt; \u0026lt;/div\u0026gt; ) } const SideBar = ({ data }) =\u0026gt; \u0026lt;List data={data} /\u0026gt; const List = ({ data }) =\u0026gt; \u0026lt;ListItem data={data} /\u0026gt; const ListItem = ({ data }) =\u0026gt; \u0026lt;span\u0026gt;{data.","keywords":["Javascript"],"articleBody":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 props 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。\n我们经常会遇到一种称为“ prop drilling”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。\n假设有一个包含某些 data 的 App 组件。在组件树的最深处，有一个 ListItem 、 Header 和 Text 组件，它们都需要来自 App 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。\nfunction App() { const data = { ... } return ( \u003cdiv\u003e \u003cSideBar data={data} /\u003e \u003cContent data={data} /\u003e \u003c/div\u003e ) } const SideBar = ({ data }) =\u003e \u003cList data={data} /\u003e const List = ({ data }) =\u003e \u003cListItem data={data} /\u003e const ListItem = ({ data }) =\u003e \u003cspan\u003e{data.listItem}\u003c/span\u003e const Content = ({ data }) =\u003e ( \u003cdiv\u003e \u003cHeader data={data} /\u003e \u003cBlock data={data} /\u003e \u003c/div\u003e ) const Header = ({ data }) =\u003e \u003cdiv\u003e{data.title}\u003c/div\u003e const Block = ({ data }) =\u003e \u003cText data={data} /\u003e const Text = ({ data }) =\u003e \u003ch1\u003e{data.text}\u003c/h1\u003e 以这种方式传递 props 可能会变得非常混乱。如果想在将来重命名 data 属性，必须在所有组件中重命名它。应用规模越大，prop 钻取就越棘手。\n如果我们能够跳过不需要使用这些数据的所有组件层，那将是最佳的。我们需要有一些东西可以让需要访问 data 值的组件直接访问它，而不依赖于 prop 钻孔。\n通过提供者模式，我们可以使得 data 供多个组件使用，可以将所有组件包装在 Provider 中，而不是通过 props 将数据传递到每一层。 Provider 是由 Context 对象提供给高阶组件。可以使用 React 提供的 createContext 方法创建一个 Context 对象。\nProvider 接收一个 value 属性，其中包含我们想要传递的数据。包含在该提供程序中的所有组件都可以访问 value 属性的值。\nconst DataContext = React.createContext() function App() { const data = { ... } return ( \u003cdiv\u003e \u003cDataContext.Provider value={data}\u003e \u003cSideBar /\u003e \u003cContent /\u003e \u003c/DataContext.Provider\u003e \u003c/div\u003e ) } 我们不再需要手动将 data 属性传递给每个组件。那么， ListItem 、 Header 和 Text 组件如何访问 data 的值呢？\n每个组件都可以通过使用 useContext 挂钩来访问 data 。此挂钩接收 data 具有引用的上下文，在本例中为 DataContext 。 useContext 钩子让我们可以读取数据并写入上下文对象。\nconst DataContext = React.createContext(); function App() { const data = { ... } return ( \u003cdiv\u003e \u003cSideBar /\u003e \u003cContent /\u003e \u003c/div\u003e ) } const SideBar = () =\u003e \u003cList /\u003e const List = () =\u003e \u003cListItem /\u003e const Content = () =\u003e \u003cdiv\u003e\u003cHeader /\u003e\u003cBlock /\u003e\u003c/div\u003e function ListItem() { const { data } = React.useContext(DataContext); return \u003cspan\u003e{data.listItem}\u003c/span\u003e; } function Text() { const { data } = React.useContext(DataContext); return \u003ch1\u003e{data.text}\u003c/h1\u003e; } function Header() { const { data } = React.useContext(DataContext); return \u003cdiv\u003e{data.title}\u003c/div\u003e; } 不使用 data 值的组件根本不必处理 data 。我们不再需要担心通过不需要 props 值的组件将 props 向下传递几个级别，这使得重构变得更加容易。\n提供者模式对于共享全局数据非常有用。提供者模式的一个常见用例是与许多组件共享主题 UI 状态。\n假设我们有一个显示列表的简单应用程序。\nexport const ThemeContext = React.createContext(); const themes = { light: { background: \"#fff\", color: \"#000\", }, dark: { background: \"#171717\", color: \"#fff\", }, }; export default function App() { const [theme, setTheme] = useState(\"dark\"); function toggleTheme() { setTheme(theme === \"light\" ? \"dark\" : \"light\"); } const providerValue = { theme: themes[theme], toggleTheme, }; return ( \u003cdiv className={`App theme-${theme}`}\u003e \u003cThemeContext.Provider value={providerValue}\u003e \u003cToggle /\u003e \u003cList /\u003e \u003c/ThemeContext.Provider\u003e \u003c/div\u003e ); } 我们希望用户能够通过切换开关在浅色模式和深色模式之间切换。当用户从浅色模式切换到深色模式时，反之亦然，背景颜色和文本颜色应该改变。我们可以将组件包装在 ThemeProvider 中，并将当前主题颜色传递给提供程序，而不是将当前主题值传递给每个组件。\n由于 Toggle 和 List 组件都包装在 ThemeContext 提供程序中，因此我们可以访问值 theme 和 toggleTheme 传递给提供者。\n在 Toggle 组件中，我们可以使用 toggleTheme 函数来相应地更新主题。\nimport React, { useContext } from \"react\"; import { ThemeContext } from \"./App\"; export default function Toggle() { const theme = useContext(ThemeContext); return ( \u003clabel className=\"switch\"\u003e \u003cinput type=\"checkbox\" onClick={theme.toggleTheme} /\u003e \u003cspan className=\"slider round\" /\u003e \u003c/label\u003e ); } List 组件本身并不关心主题的当前值。但是， ListItem 组件关系。我们可以直接在 ListItem 中使用 theme 上下文。不必将任何数据传递给不关心主题当前值的组件。\nimport React, { useContext } from \"react\"; import { ThemeContext } from \"./App\"; export default function TextBox() { const theme = useContext(ThemeContext); return \u003cli style={theme.theme}\u003e...\u003c/li\u003e; } Hooks 我们可以创建一个 hook 来为组件提供上下文。使用一个返回需要的上下文的钩子，而无须在每个组件中导入 useContext 和上下文。\n为了确保它是一个有效的主题，如果 useContext(ThemeContext) 返回一个虚假值，我们将抛出一个错误。\nfunction useThemeContext() { const theme = useContext(ThemeContext); if (!theme) { throw new Error(\"useThemeContext must be used within ThemeProvider\"); } return theme; } 我们可以创建一个 HOC 来包装组件以提供其值，而不是直接使用 ThemeContext.Provider 组件来包装组件。这样，我们可以将上下文逻辑与渲染组件分离，从而提高提供者的可重用性。\nfunction ThemeProvider({ children }) { const [theme, setTheme] = useState(\"dark\"); function toggleTheme() { setTheme(theme === \"light\" ? \"dark\" : \"light\"); } const providerValue = { theme: themes[theme], toggleTheme, }; return ( \u003cThemeContext.Provider value={providerValue}\u003e {children} \u003c/ThemeContext.Provider\u003e ); } export default function App() { return ( \u003cdiv className={`App theme-${theme}`}\u003e \u003cThemeProvider\u003e \u003cToggle /\u003e \u003cList /\u003e \u003c/ThemeProvider\u003e \u003c/div\u003e ); } 每个需要访问 ThemeContext 的组件现在可以简单地使用 useThemeContext 钩子。\nexport default function TextBox() { const theme = useThemeContext(); return \u003cli style={theme.theme}\u003e...\u003c/li\u003e; } 通过为不同的上下文创建钩子，可以轻松地将提供者的逻辑与呈现数据的组件分开。\n案例分析 一些库提供内置提供程序，我们可以在使用组件中使用这些值。一个很好的例子是styled-components。\nNo experience with styled-components is needed to understand this example.\nstyled-components库为我们提供了一个 ThemeProvider 。每个样式组件都可以访问该提供程序的值。我们可以使用提供给我们的 API，而不是自己创建上下文 API。\n让我们使用相同的 List 示例，并将组件包装在从 styled-component 库导入的 ThemeProvider 中。\nimport { ThemeProvider } from \"styled-components\"; export default function App() { const [theme, setTheme] = useState(\"dark\"); function toggleTheme() { setTheme(theme === \"light\" ? \"dark\" : \"light\"); } return ( \u003cdiv className={`App theme-${theme}`}\u003e \u003cThemeProvider theme={themes[theme]}\u003e \u003cToggle toggleTheme={toggleTheme} /\u003e \u003cList /\u003e \u003c/ThemeProvider\u003e \u003c/div\u003e ); } 我们不会将内联 style 属性传递给 ListItem 组件，而是将其设为 styled.li 组件。由于它是一个样式组件，我们可以访问 theme 的值。\nimport styled from \"styled-components\"; export default function ListItem() { return ( \u003cLi\u003e Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. \u003c/Li\u003e ); } const Li = styled.li` ${({ theme }) =\u003e ` background-color: ${theme.backgroundColor}; color: ${theme.color}; `} `; 优点 Provider 模式/Context API 使得将数据传递到许多组件成为可能，而无需手动通过每个组件层传递数据。\n它降低了重构代码时意外引入错误的风险。以前，如果我们稍后想要重命名某个 prop，则必须在使用该值的整个应用程序中重命名该 prop。\n我们不再需要处理 prop-drilling,，这可以被视为一种反模式。以前，理解应用程序的数据流可能很困难，因为并不总是清楚某些 prop 值的起源。使用 Provider 模式，我们不再需要将 props 不必要地传递给不关心这些数据的组件。\n使用提供者模式可以轻松保持某种全局状态，因为我们可以让组件访问此全局状态。\n缺点 在某些情况下，过度使用提供者模式可能会导致性能问题。所有使用上下文的组件都会在每次状态更改时重新渲染。\n举个例子，有一个简单的计数器，每次单击 Button 组件中的 Increment 按钮时，该计数器的值就会增加。在 Reset 组件中还有一个 Reset 按钮，它将计数重置回 0 。\n但是，当单击 Increment 时，会发现重新渲染的不仅仅是计数。 Reset 组件中的日期也会重新呈现。\nReset 组件也重新渲染，因为它消耗了 useCountContext 。在较小的应用程序中，这并不重要。在较大的应用程序中，将频繁更新的值传递给许多组件可能会对性能产生负面影响。\n为了确保组件不会使用包含可能更新的不必要值的 Provider，可以为特定的用例创建多个 Provider。\n","wordCount":"744","inLanguage":"en","datePublished":"2023-08-20T20:06:34+08:00","dateModified":"2023-08-20T20:06:34+08:00","author":{"@type":"Person","name":"Anna.me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://annachengdesu.github.io/post/patterns/provider/"},"publisher":{"@type":"Organization","name":"Anna.me","logo":{"@type":"ImageObject","url":"https://annachengdesu.github.io/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://annachengdesu.github.io/ accesskey=h title="Anna.me (Alt + H)">Anna.me</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://annachengdesu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://annachengdesu.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://annachengdesu.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://annachengdesu.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://annachengdesu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://annachengdesu.github.io/post/>Posts</a></div><h1 class=post-title>09-Provider Pattern 提供者模式-vanilla篇</h1><div class=post-meta><span title='2023-08-20 20:06:34 +0800 CST'>August 20, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;744 words&nbsp;·&nbsp;Anna.me</div></header><div class=post-content><p>在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。尽管可以使用 <code>props</code> 将数据传递给组件，但如果应用程序中几乎所有组件都需要访问 props 的值，那么这可能很难做到。</p><p>我们经常会遇到一种称为“ <em>prop drilling</em>”的情况，将props传递到组件树的深处时，就会出现这种情况。重构依赖于 props 的代码几乎是不可能的，并且知道某些数据来自哪里也很困难。</p><p>假设有一个包含某些 data 的 <code>App</code> 组件。在组件树的最深处，有一个 <code>ListItem</code> 、 <code>Header</code> 和 <code>Text</code> 组件，它们都需要来自 <code>App</code> 的data。为了将这些数据传递给这些组件，必须将其传递给多层组件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>SideBar</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>Content</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SideBar</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>List</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>List</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>ListItem</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ListItem</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>span</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>listItem</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/span&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Content</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>Header</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>Block</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Header</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Block</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>Text</span> <span class=nx>data</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Text</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>data</span> <span class=p>})</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span></code></pre></div><p>以这种方式传递 props 可能会变得非常混乱。如果想在将来重命名 <code>data</code> 属性，必须在所有组件中重命名它。应用规模越大，prop 钻取就越棘手。</p><p>如果我们能够跳过不需要使用这些数据的所有组件层，那将是最佳的。我们需要有一些东西可以让需要访问 <code>data</code> 值的组件直接访问它，而不依赖于 prop 钻孔。</p><p>通过提供者模式，我们可以使得 data 供多个组件使用，可以将所有组件包装在 <code>Provider</code> 中，而不是通过 props 将数据传递到每一层。 Provider 是由 <code>Context</code> 对象提供给高阶组件。可以使用 React 提供的 <code>createContext</code> 方法创建一个 Context 对象。</p><p>Provider 接收一个 <code>value</code> 属性，其中包含我们想要传递的数据。包含在该提供程序中的所有组件都可以访问 <code>value</code> 属性的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>DataContext</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createContext</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>DataContext</span><span class=p>.</span><span class=nx>Provider</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=nx>data</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>SideBar</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>Content</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/DataContext.Provider&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们不再需要手动将 <code>data</code> 属性传递给每个组件。那么， <code>ListItem</code> 、 <code>Header</code> 和 <code>Text</code> 组件如何访问 <code>data</code> 的值呢？</p><p>每个组件都可以通过使用 <code>useContext</code> 挂钩来访问 <code>data</code> 。此挂钩接收 <code>data</code> 具有引用的上下文，在本例中为 <code>DataContext</code> 。 <code>useContext</code> 钩子让我们可以读取数据并写入上下文对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>DataContext</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createContext</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>SideBar</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>Content</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SideBar</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>List</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>List</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>ListItem</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Content</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;&lt;</span><span class=nx>Header</span> <span class=o>/&gt;&lt;</span><span class=nx>Block</span> <span class=o>/&gt;&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>ListItem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>data</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>useContext</span><span class=p>(</span><span class=nx>DataContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>span</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>listItem</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/span&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Text</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>data</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>useContext</span><span class=p>(</span><span class=nx>DataContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Header</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>data</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>useContext</span><span class=p>(</span><span class=nx>DataContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>data</span><span class=p>.</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>不使用 <code>data</code> 值的组件根本不必处理 <code>data</code> 。我们不再需要担心通过不需要 props 值的组件将 props 向下传递几个级别，这使得重构变得更加容易。</p><p>提供者模式对于共享全局数据非常有用。提供者模式的一个常见用例是与许多组件共享主题 UI 状态。</p><p>假设我们有一个显示列表的简单应用程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>ThemeContext</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createContext</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>themes</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>light</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>background</span><span class=o>:</span> <span class=s2>&#34;#fff&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>color</span><span class=o>:</span> <span class=s2>&#34;#000&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>dark</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>background</span><span class=o>:</span> <span class=s2>&#34;#171717&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>color</span><span class=o>:</span> <span class=s2>&#34;#fff&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>theme</span><span class=p>,</span> <span class=nx>setTheme</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;dark&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>toggleTheme</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTheme</span><span class=p>(</span><span class=nx>theme</span> <span class=o>===</span> <span class=s2>&#34;light&#34;</span> <span class=o>?</span> <span class=s2>&#34;dark&#34;</span> <span class=o>:</span> <span class=s2>&#34;light&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>providerValue</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>theme</span><span class=o>:</span> <span class=nx>themes</span><span class=p>[</span><span class=nx>theme</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nx>toggleTheme</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=p>{</span><span class=sb>`App theme-</span><span class=si>${</span><span class=nx>theme</span><span class=si>}</span><span class=sb>`</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>ThemeContext</span><span class=p>.</span><span class=nx>Provider</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=nx>providerValue</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>Toggle</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>List</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/ThemeContext.Provider&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们希望用户能够通过切换开关在浅色模式和深色模式之间切换。当用户从浅色模式切换到深色模式时，反之亦然，背景颜色和文本颜色应该改变。我们可以将组件包装在 <code>ThemeProvider</code> 中，并将当前主题颜色传递给提供程序，而不是将当前主题值传递给每个组件。</p><p>由于 <code>Toggle</code> 和 <code>List</code> 组件都包装在 <code>ThemeContext</code> 提供程序中，因此我们可以访问值 <code>theme</code> 和 <code>toggleTheme</code> 传递给提供者。</p><p>在 <code>Toggle</code> 组件中，我们可以使用 <code>toggleTheme</code> 函数来相应地更新主题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useContext</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>ThemeContext</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;./App&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Toggle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>theme</span> <span class=o>=</span> <span class=nx>useContext</span><span class=p>(</span><span class=nx>ThemeContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>label</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;switch&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>type</span><span class=o>=</span><span class=s2>&#34;checkbox&#34;</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>theme</span><span class=p>.</span><span class=nx>toggleTheme</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>span</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;slider round&#34;</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/label&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>List</code> 组件本身并不关心主题的当前值。但是， <code>ListItem</code> 组件关系。我们可以直接在 <code>ListItem</code> 中使用 <code>theme</code> 上下文。不必将任何数据传递给不关心主题当前值的组件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useContext</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>ThemeContext</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;./App&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>TextBox</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>theme</span> <span class=o>=</span> <span class=nx>useContext</span><span class=p>(</span><span class=nx>ThemeContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>li</span> <span class=nx>style</span><span class=o>=</span><span class=p>{</span><span class=nx>theme</span><span class=p>.</span><span class=nx>theme</span><span class=p>}</span><span class=o>&gt;</span><span class=p>...</span><span class=o>&lt;</span><span class=err>/li&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=hooks>Hooks<a hidden class=anchor aria-hidden=true href=#hooks>#</a></h3><p>我们可以创建一个 hook 来为组件提供上下文。使用一个返回需要的上下文的钩子，而无须在每个组件中导入 <code>useContext</code> 和上下文。</p><p>为了确保它是一个有效的主题，如果 <code>useContext(ThemeContext)</code> 返回一个虚假值，我们将抛出一个错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>useThemeContext</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>theme</span> <span class=o>=</span> <span class=nx>useContext</span><span class=p>(</span><span class=nx>ThemeContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>theme</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;useThemeContext must be used within ThemeProvider&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>theme</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以创建一个 HOC 来包装组件以提供其值，而不是直接使用 <code>ThemeContext.Provider</code> 组件来包装组件。这样，我们可以将上下文逻辑与渲染组件分离，从而提高提供者的可重用性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>ThemeProvider</span><span class=p>({</span> <span class=nx>children</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>theme</span><span class=p>,</span> <span class=nx>setTheme</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;dark&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>toggleTheme</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTheme</span><span class=p>(</span><span class=nx>theme</span> <span class=o>===</span> <span class=s2>&#34;light&#34;</span> <span class=o>?</span> <span class=s2>&#34;dark&#34;</span> <span class=o>:</span> <span class=s2>&#34;light&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>providerValue</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>theme</span><span class=o>:</span> <span class=nx>themes</span><span class=p>[</span><span class=nx>theme</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nx>toggleTheme</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>ThemeContext</span><span class=p>.</span><span class=nx>Provider</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=nx>providerValue</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=nx>children</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/ThemeContext.Provider&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=p>{</span><span class=sb>`App theme-</span><span class=si>${</span><span class=nx>theme</span><span class=si>}</span><span class=sb>`</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>ThemeProvider</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>Toggle</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>List</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/ThemeProvider&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>每个需要访问 <code>ThemeContext</code> 的组件现在可以简单地使用 <code>useThemeContext</code> 钩子。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>TextBox</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>theme</span> <span class=o>=</span> <span class=nx>useThemeContext</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>li</span> <span class=nx>style</span><span class=o>=</span><span class=p>{</span><span class=nx>theme</span><span class=p>.</span><span class=nx>theme</span><span class=p>}</span><span class=o>&gt;</span><span class=p>...</span><span class=o>&lt;</span><span class=err>/li&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过为不同的上下文创建钩子，可以轻松地将提供者的逻辑与呈现数据的组件分开。</p><h2 id=案例分析>案例分析<a hidden class=anchor aria-hidden=true href=#案例分析>#</a></h2><p>一些库提供内置提供程序，我们可以在使用组件中使用这些值。一个很好的例子是<a href=https://styled-components.com/docs/advanced>styled-components</a>。</p><p><em>No experience with styled-components is needed to understand this example.</em></p><p>styled-components库为我们提供了一个 <code>ThemeProvider</code> 。每个样式组件都可以访问该提供程序的值。我们可以使用提供给我们的 API，而不是自己创建上下文 API。</p><p>让我们使用相同的 List 示例，并将组件包装在从 <code>styled-component</code> 库导入的 <code>ThemeProvider</code> 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>ThemeProvider</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;styled-components&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>theme</span><span class=p>,</span> <span class=nx>setTheme</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;dark&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>toggleTheme</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTheme</span><span class=p>(</span><span class=nx>theme</span> <span class=o>===</span> <span class=s2>&#34;light&#34;</span> <span class=o>?</span> <span class=s2>&#34;dark&#34;</span> <span class=o>:</span> <span class=s2>&#34;light&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=p>{</span><span class=sb>`App theme-</span><span class=si>${</span><span class=nx>theme</span><span class=si>}</span><span class=sb>`</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>ThemeProvider</span> <span class=nx>theme</span><span class=o>=</span><span class=p>{</span><span class=nx>themes</span><span class=p>[</span><span class=nx>theme</span><span class=p>]}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>Toggle</span> <span class=nx>toggleTheme</span><span class=o>=</span><span class=p>{</span><span class=nx>toggleTheme</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=nx>List</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/ThemeProvider&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们不会将内联 <code>style</code> 属性传递给 <code>ListItem</code> 组件，而是将其设为 <code>styled.li</code> 组件。由于它是一个样式组件，我们可以访问 <code>theme</code> 的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>import</span> <span class=nx>styled</span> <span class=nx>from</span> <span class=s2>&#34;styled-components&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>ListItem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>Li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>Lorem</span> <span class=nx>ipsum</span> <span class=nx>dolor</span> <span class=nx>sit</span> <span class=nx>amet</span><span class=p>,</span> <span class=nx>consectetur</span> <span class=nx>adipiscing</span> <span class=nx>elit</span><span class=p>,</span> <span class=nx>sed</span> <span class=k>do</span> <span class=nx>eiusmod</span>
</span></span><span class=line><span class=cl>      <span class=nx>tempor</span> <span class=nx>incididunt</span> <span class=nx>ut</span> <span class=nx>labore</span> <span class=nx>et</span> <span class=nx>dolore</span> <span class=nx>magna</span> <span class=nx>aliqua</span><span class=p>.</span> <span class=nx>Ut</span> <span class=nx>enim</span> <span class=nx>ad</span> <span class=nx>minim</span>
</span></span><span class=line><span class=cl>      <span class=nx>veniam</span><span class=p>,</span> <span class=nx>quis</span> <span class=nx>nostrud</span> <span class=nx>exercitation</span> <span class=nx>ullamco</span> <span class=nx>laboris</span> <span class=nx>nisi</span> <span class=nx>ut</span> <span class=nx>aliquip</span> <span class=nx>ex</span> <span class=nx>ea</span>
</span></span><span class=line><span class=cl>      <span class=nx>commodo</span> <span class=nx>consequat</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>Li</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Li</span> <span class=o>=</span> <span class=nx>styled</span><span class=p>.</span><span class=nx>li</span><span class=sb>`
</span></span></span><span class=line><span class=cl><span class=sb>  </span><span class=si>${</span><span class=p>({</span> <span class=nx>theme</span> <span class=si>}</span><span class=sb>) =&gt; `</span>
</span></span><span class=line><span class=cl>     <span class=nx>background</span><span class=o>-</span><span class=nx>color</span><span class=o>:</span> <span class=nx>$</span><span class=p>{</span><span class=nx>theme</span><span class=p>.</span><span class=nx>backgroundColor</span><span class=p>};</span>
</span></span><span class=line><span class=cl>     <span class=nx>color</span><span class=o>:</span> <span class=nx>$</span><span class=p>{</span><span class=nx>theme</span><span class=p>.</span><span class=nx>color</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=sb>`}
</span></span></span><span class=line><span class=cl><span class=sb>`</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=优点>优点<a hidden class=anchor aria-hidden=true href=#优点>#</a></h3><p>Provider 模式/Context API 使得将数据传递到许多组件成为可能，而无需手动通过每个组件层传递数据。</p><p>它降低了重构代码时意外引入错误的风险。以前，如果我们稍后想要重命名某个 prop，则必须在使用该值的整个应用程序中重命名该 prop。</p><p>我们不再需要处理 <em>prop-drilling</em>,，这可以被视为一种反模式。以前，理解应用程序的数据流可能很困难，因为并不总是清楚某些 prop 值的起源。使用 Provider 模式，我们不再需要将 props 不必要地传递给不关心这些数据的组件。</p><p>使用提供者模式可以轻松保持某种全局状态，因为我们可以让组件访问此全局状态。</p><h3 id=缺点>缺点<a hidden class=anchor aria-hidden=true href=#缺点>#</a></h3><p>在某些情况下，过度使用提供者模式可能会导致性能问题。所有使用上下文的组件都会在每次状态更改时重新渲染。</p><p>举个例子，有一个简单的计数器，每次单击 <code>Button</code> 组件中的 <code>Increment</code> 按钮时，该计数器的值就会增加。在 <code>Reset</code> 组件中还有一个 <code>Reset</code> 按钮，它将计数重置回 <code>0</code> 。</p><p>但是，当单击 <code>Increment</code> 时，会发现重新渲染的不仅仅是计数。 <code>Reset</code> 组件中的日期也会重新呈现。</p><p><code>Reset</code> 组件也重新渲染，因为它消耗了 <code>useCountContext</code> 。在较小的应用程序中，这并不重要。在较大的应用程序中，将频繁更新的值传递给许多组件可能会对性能产生负面影响。</p><p>为了确保组件不会使用包含可能更新的不必要值的 Provider，可以为特定的用例创建多个 Provider。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://annachengdesu.github.io/tags/javascript/>Javascript</a></li></ul><nav class=paginav><a class=prev href=https://annachengdesu.github.io/post/patterns/summary/><span class=title>« Prev</span><br><span>设计模式汇总及学习心得总结(Updating...)</span></a>
<a class=next href=https://annachengdesu.github.io/post/patterns/module/><span class=title>Next »</span><br><span>08-Module Pattern 模块模式-vanilla篇</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://annachengdesu.github.io/>Anna.me</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>