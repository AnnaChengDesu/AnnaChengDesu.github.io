<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>06-Singleton Pattern-设计模式学习-vanilla篇 | Anna.me</title><meta name=keywords content="Javascript"><meta name=description content="Singleton Pattern 单例模式 单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。
首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：
返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。
let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console."><meta name=author content="Anna.me"><link rel=canonical href=https://annachengdesu.github.io/post/patterns/singleton/><link crossorigin=anonymous href=/assets/css/stylesheet.f2da42eb72c6ac4b82b92c21716a96ae77ab6a2505a713280483eee56482a913.css integrity="sha256-8tpC63LGrEuCuSwhcWqWrneraiUFpxMoBIPu5WSCqRM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://annachengdesu.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://annachengdesu.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="06-Singleton Pattern-设计模式学习-vanilla篇"><meta property="og:description" content="Singleton Pattern 单例模式 单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。
首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：
返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。
let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console."><meta property="og:type" content="article"><meta property="og:url" content="https://annachengdesu.github.io/post/patterns/singleton/"><meta property="og:image" content="https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-08-05T21:13:09+08:00"><meta property="article:modified_time" content="2023-08-05T21:13:09+08:00"><meta property="og:site_name" content="Anna.me"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://annachengdesu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="06-Singleton Pattern-设计模式学习-vanilla篇"><meta name=twitter:description content="Singleton Pattern 单例模式 单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。
首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：
返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。
let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://annachengdesu.github.io/post/"},{"@type":"ListItem","position":2,"name":"06-Singleton Pattern-设计模式学习-vanilla篇","item":"https://annachengdesu.github.io/post/patterns/singleton/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"06-Singleton Pattern-设计模式学习-vanilla篇","name":"06-Singleton Pattern-设计模式学习-vanilla篇","description":"Singleton Pattern 单例模式 单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。\n首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：\n返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。\nlet counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.","keywords":["Javascript"],"articleBody":"Singleton Pattern 单例模式 单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。\n首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 Counter 类，它具有：\n返回实例值的 getInstance 方法 返回 counter 变量当前值的 getCount 方法 将 counter 的值增加 1 的 increment 方法 将 counter 的值减一的 decrement 方法 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } 然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 Counter 类的多个实例。\nlet counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.log(counter1.getInstance() === counter2.getInstance()); // false 通过调用 new 方法两次，我们只需将 counter1 和 counter2 设置为等于不同的实例。 counter1 和 counter2 上的 getInstance 方法返回的值实际上返回了对不同实例的引用：它们并不严格相等。\n让我们确保只能创建 Counter 类的一个实例。\n确保只能创建一个实例的一种方法是创建一个名为 instance 的变量。在 Counter 的构造函数中，我们可以在创建新实例时将 instance 设置为对该实例的引用。我们可以通过检查 instance 变量是否已经有值来防止新的实例化。如果是这种情况，则实例已经存在。这种情况不应该发生：应该抛出错误让用户知道。\nlet instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\"You can only create one instance!\"); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); // Error: You can only create one instance! 我们无法再创建多个实例。\n让我们从 counter.js 文件中导出 Counter 实例。但在此之前，我们也应该冻结实例。 Object.freeze 方法确保使用代码无法修改单例。无法添加或修改冻结实例上的属性，这降低了意外覆盖单例上的值的风险。\nlet instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\"You can only create one instance!\"); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter; 让我们看一下实现 Counter 示例的应用程序。我们有以下文件：\ncounter.js ：包含 Counter 类，并导出 Counter 实例作为其默认导出\nindex.js ：加载 redButton.js 和 blueButton.js 模块\nredButton.js: 导入 Counter, 并将 Counter的 increment 方法添加为红色按钮的事件监听器，并记录当前值通过调用 getCount 方法来实现counter\nblueButton.js ：导入 Counter ，并将 Counter 的 increment 方法作为事件侦听器添加到蓝色按钮，并记录当前值通过调用 getCount 方法来实现 counter\nblueButton.js 和 redButton.js 都从 counter.js 导入相同的实例。该实例在两个文件中均作为 Counter 导入。\n当我们在 redButton.js 或 blueButton.js 中调用 increment 方法时， Counter 属性的值\u003e 两个文件中的实例更新。我们点击红色还是蓝色按钮并不重要：所有实例共享相同的值。这就是为什么即使我们在不同的文件中调用该方法，计数器也会不断增加 1。\n权衡 将实例化限制为仅一个实例可能会节省大量内存空间。我们不必每次都为一个新实例设置内存，而只需为该一个实例设置内存，该实例在整个应用程序中都会被引用。然而，单例实际上被认为是一种反模式，并且可以（或..应该）在 JavaScript 中避免。\n在许多编程语言中，例如 Java 或 C++，不可能像 JavaScript 那样直接创建对象。在那些面向对象的编程语言中，我们需要创建一个类，它创建一个对象。创建的对象具有类实例的值，就像 JavaScript 示例中 instance 的值一样。\n然而，上面示例中显示的类实现实际上是多余的。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。让我们来看看使用单例的一些缺点。\n使用常规对象 让我们使用之前看到的相同示例。然而这一次， counter 只是一个包含以下内容的对象：\na count property count 属性 将 count 的值增加 1 的 increment 方法 将 count 的值减一的 decrement 方法 let count = 0; const counter = { increment() { return ++count; }, decrement() { return --count; } }; Object.freeze(counter); export { counter }; 由于对象是通过引用传递的，因此 redButton.js 和 blueButton.js 都导入对同一 counter 对象的引用。修改这两个文件中的 count 的值将修改 counter 上的值，该值在这两个文件中都可见。\n测试 测试依赖于单例的代码可能会很棘手。由于我们无法每次都创建新实例，因此所有测试都依赖于对上一次测试的全局实例的修改。在这种情况下，测试的顺序很重要，一个小的修改可能会导致整个测试套件失败。测试完成后，我们需要重置整个实例，以重置测试所做的修改。\nmport Counter from \"../src/counterTest\"; test(\"incrementing 1 time should be 1\", () =\u003e { Counter.increment(); expect(Counter.getCount()).toBe(1); }); test(\"incrementing 3 extra times should be 4\", () =\u003e { Counter.increment(); Counter.increment(); Counter.increment(); expect(Counter.getCount()).toBe(4); }); test(\"decrementing 1 times should be 3\", () =\u003e { Counter.decrement(); expect(Counter.getCount()).toBe(3); }); 依赖隐藏 当导入另一个模块时，在这种情况下 superCounter.js ，模块正在导入 Singleton 可能并不明显。在其他文件中，例如本例中的 index.js ，我们可能会导入该模块并调用其方法。这样，我们就无意中修改了Singleton中的值。这可能会导致意外的行为，因为单例的多个实例可以在整个应用程序中共享，这些实例也都会被修改。\nimport Counter from \"./counter\"; export default class SuperCounter { constructor() { this.count = 0; } increment() { Counter.increment(); return (this.count += 100); } decrement() { Counter.decrement(); return (this.count -= 100); } } 全局行为 Singleton 实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，因此我们可以在整个应用程序中访问这些变量。\n拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，这可能会导致许多意外行为。\n在 ES2015 中，创建全局变量相当罕见。新的 let 和 const 关键字通过将使用这两个关键字声明的变量保持在块范围内，可以防止开发人员意外污染全局范围。 JavaScript 中的新 module 系统可以更轻松地创建全局可访问的值，而不会污染全局范围，因为能够从模块获取 export 值，以及 import 这些值在其他文件中。\n然而，单例的常见用例是在整个应用程序中拥有某种全局状态。让代码库的多个部分依赖于同一个可变对象可能会导致意外的行为。\n通常，代码库的某些部分会修改全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据可供使用时意外地首先使用数据。随着应用程序的增长，并且数十个组件相互依赖，理解使用全局状态时的数据流可能会变得非常棘手。\nReact 中的状态管理 在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用单例。尽管它们的全局状态行为可能看起来与单例的行为类似，但这些工具提供只读状态而不是单例的可变状态。使用 Redux 时，在组件通过dispatcher发送操作后，只有纯函数reducers才能更新状态。\n尽管使用这些工具并不会神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们预期的方式发生变化，因为组件无法直接更新状态。\n","wordCount":"508","inLanguage":"en","datePublished":"2023-08-05T21:13:09+08:00","dateModified":"2023-08-05T21:13:09+08:00","author":{"@type":"Person","name":"Anna.me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://annachengdesu.github.io/post/patterns/singleton/"},"publisher":{"@type":"Organization","name":"Anna.me","logo":{"@type":"ImageObject","url":"https://annachengdesu.github.io/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://annachengdesu.github.io/ accesskey=h title="Anna.me (Alt + H)">Anna.me</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://annachengdesu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://annachengdesu.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://annachengdesu.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://annachengdesu.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://annachengdesu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://annachengdesu.github.io/post/>Posts</a></div><h1 class=post-title>06-Singleton Pattern-设计模式学习-vanilla篇</h1><div class=post-meta><span title='2023-08-05 21:13:09 +0800 CST'>August 5, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;508 words&nbsp;·&nbsp;Anna.me</div></header><div class=post-content><h1 id=singleton-pattern-单例模式>Singleton Pattern 单例模式<a hidden class=anchor aria-hidden=true href=#singleton-pattern-单例模式>#</a></h1><p>单例是可以实例化一次并可以全局访问的类。单一实例可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。</p><p>首先，看一下使用 ES2015 类的单例是什么样子。对于这个例子，我们将构建一个 <code>Counter</code> 类，它具有：</p><ul><li>返回实例值的 <code>getInstance</code> 方法</li><li>返回 <code>counter</code> 变量当前值的 <code>getCount</code> 方法</li><li>将 <code>counter</code> 的值增加 1 的 <code>increment</code> 方法</li><li>将 <code>counter</code> 的值减一的 <code>decrement</code> 方法</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>getInstance</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>++</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>--</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然而，这个类不符合 Singleton 的标准。 Singleton 应该只能被实例化一次。目前，我们可以创建 <code>Counter</code> 类的多个实例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>getInstance</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>++</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>--</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter1</span><span class=p>.</span><span class=nx>getInstance</span><span class=p>()</span> <span class=o>===</span> <span class=nx>counter2</span><span class=p>.</span><span class=nx>getInstance</span><span class=p>());</span> <span class=c1>// false
</span></span></span></code></pre></div><p>通过调用 <code>new</code> 方法两次，我们只需将 <code>counter1</code> 和 <code>counter2</code> 设置为等于不同的实例。 <code>counter1</code> 和 <code>counter2</code> 上的 <code>getInstance</code> 方法返回的值实际上返回了对不同实例的引用：它们并不严格相等。</p><p>让我们确保只能创建 <code>Counter</code> 类的一个实例。</p><p>确保只能创建一个实例的一种方法是创建一个名为 <code>instance</code> 的变量。在 <code>Counter</code> 的构造函数中，我们可以在创建新实例时将 <code>instance</code> 设置为对该实例的引用。我们可以通过检查 <code>instance</code> 变量是否已经有值来防止新的实例化。如果是这种情况，则实例已经存在。这种情况不应该发生：应该抛出错误让用户知道。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>instance</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>instance</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;You can only create one instance!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getInstance</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>++</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>--</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// Error: You can only create one instance!
</span></span></span></code></pre></div><p>我们无法再创建多个实例。</p><p>让我们从 <code>counter.js</code> 文件中导出 <code>Counter</code> 实例。但在此之前，我们也应该冻结实例。 <code>Object.freeze</code> 方法确保使用代码无法修改单例。无法添加或修改冻结实例上的属性，这降低了意外覆盖单例上的值的风险。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>instance</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>instance</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;You can only create one instance!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>instance</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getInstance</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>getCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>++</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>--</span><span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>singletonCounter</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>freeze</span><span class=p>(</span><span class=k>new</span> <span class=nx>Counter</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>singletonCounter</span><span class=p>;</span>
</span></span></code></pre></div><p>让我们看一下实现 <code>Counter</code> 示例的应用程序。我们有以下文件：</p><p><code>counter.js</code> ：包含 <code>Counter</code> 类，并导出 <code>Counter</code> 实例作为其默认导出</p><p><code>index.js</code> ：加载 <code>redButton.js</code> 和 <code>blueButton.js</code> 模块</p><p><code>redButton.js</code>: 导入 <code>Counter</code>, 并将 <code>Counter</code>的 <code>increment</code> 方法添加为红色按钮的事件监听器，并记录当前值通过调用 <code>getCount</code> 方法来实现<code>counter</code></p><p><code>blueButton.js</code> ：导入 <code>Counter</code> ，并将 <code>Counter</code> 的 <code>increment</code> 方法作为事件侦听器添加到蓝色按钮，并记录当前值通过调用 <code>getCount</code> 方法来实现 <code>counter</code></p><p><code>blueButton.js</code> 和 <code>redButton.js</code> 都从 <code>counter.js</code> 导入相同的实例。该实例在两个文件中均作为 <code>Counter</code> 导入。</p><p>当我们在 <code>redButton.js</code> 或 <code>blueButton.js</code> 中调用 <code>increment</code> 方法时， <code>Counter</code> 属性的值> 两个文件中的实例更新。我们点击红色还是蓝色按钮并不重要：所有实例共享相同的值。这就是为什么即使我们在不同的文件中调用该方法，计数器也会不断增加 1。</p><h2 id=权衡>权衡<a hidden class=anchor aria-hidden=true href=#权衡>#</a></h2><p>将实例化限制为仅一个实例可能会节省大量内存空间。我们不必每次都为一个新实例设置内存，而只需为该一个实例设置内存，该实例在整个应用程序中都会被引用。然而，单例实际上被认为是一种反模式，并且可以（或..应该）在 JavaScript 中避免。</p><p>在许多编程语言中，例如 Java 或 C++，不可能像 JavaScript 那样直接创建对象。在那些面向对象的编程语言中，我们需要创建一个类，它创建一个对象。创建的对象具有类实例的值，就像 JavaScript 示例中 <code>instance</code> 的值一样。</p><p>然而，上面示例中显示的类实现实际上是多余的。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。让我们来看看使用单例的一些缺点。</p><h3 id=使用常规对象>使用常规对象<a hidden class=anchor aria-hidden=true href=#使用常规对象>#</a></h3><p>让我们使用之前看到的相同示例。然而这一次， <code>counter</code> 只是一个包含以下内容的对象：</p><ul><li>a <code>count</code> property <code>count</code> 属性</li><li>将 <code>count</code> 的值增加 1 的 <code>increment</code> 方法</li><li>将 <code>count</code> 的值减一的 <code>decrement</code> 方法</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>++</span><span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>--</span><span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Object</span><span class=p>.</span><span class=nx>freeze</span><span class=p>(</span><span class=nx>counter</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=p>{</span> <span class=nx>counter</span> <span class=p>};</span>
</span></span></code></pre></div><p>由于对象是通过引用传递的，因此 <code>redButton.js</code> 和 <code>blueButton.js</code> 都导入对同一 <code>counter</code> 对象的引用。修改这两个文件中的 <code>count</code> 的值将修改 <code>counter</code> 上的值，该值在这两个文件中都可见。</p><h3 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h3><p>测试依赖于单例的代码可能会很棘手。由于我们无法每次都创建新实例，因此所有测试都依赖于对上一次测试的全局实例的修改。在这种情况下，测试的顺序很重要，一个小的修改可能会导致整个测试套件失败。测试完成后，我们需要重置整个实例，以重置测试所做的修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>mport</span> <span class=nx>Counter</span> <span class=nx>from</span> <span class=s2>&#34;../src/counterTest&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s2>&#34;incrementing 1 time should be 1&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>Counter</span><span class=p>.</span><span class=nx>getCount</span><span class=p>()).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s2>&#34;incrementing 3 extra times should be 4&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>Counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>Counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>Counter</span><span class=p>.</span><span class=nx>getCount</span><span class=p>()).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s2>&#34;decrementing 1  times should be 3&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Counter</span><span class=p>.</span><span class=nx>decrement</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>Counter</span><span class=p>.</span><span class=nx>getCount</span><span class=p>()).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><h4 id=依赖隐藏>依赖隐藏<a hidden class=anchor aria-hidden=true href=#依赖隐藏>#</a></h4><p>当导入另一个模块时，在这种情况下 <code>superCounter.js</code> ，模块正在导入 Singleton 可能并不明显。在其他文件中，例如本例中的 <code>index.js</code> ，我们可能会导入该模块并调用其方法。这样，我们就无意中修改了Singleton中的值。这可能会导致意外的行为，因为单例的多个实例可以在整个应用程序中共享，这些实例也都会被修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=nx>Counter</span> <span class=nx>from</span> <span class=s2>&#34;./counter&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kr>class</span> <span class=nx>SuperCounter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>count</span> <span class=o>+=</span> <span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>decrement</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Counter</span><span class=p>.</span><span class=nx>decrement</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>count</span> <span class=o>-=</span> <span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=全局行为>全局行为<a hidden class=anchor aria-hidden=true href=#全局行为>#</a></h3><p>Singleton 实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，因此我们可以在整个应用程序中访问这些变量。</p><p>拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，这可能会导致许多意外行为。</p><p>在 ES2015 中，创建全局变量相当罕见。新的 <code>let</code> 和 <code>const</code> 关键字通过将使用这两个关键字声明的变量保持在块范围内，可以防止开发人员意外污染全局范围。 JavaScript 中的新 <code>module</code> 系统可以更轻松地创建全局可访问的值，而不会污染全局范围，因为能够从模块获取 <code>export</code> 值，以及 <code>import</code> 这些值在其他文件中。</p><p>然而，单例的常见用例是在整个应用程序中拥有某种全局状态。让代码库的多个部分依赖于同一个可变对象可能会导致意外的行为。</p><p>通常，代码库的某些部分会修改全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据可供使用时意外地首先使用数据。随着应用程序的增长，并且数十个组件相互依赖，理解使用全局状态时的数据流可能会变得非常棘手。</p><h3 id=react-中的状态管理>React 中的状态管理<a hidden class=anchor aria-hidden=true href=#react-中的状态管理>#</a></h3><p>在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用单例。尽管它们的全局状态行为可能看起来与单例的行为类似，但这些工具提供<strong>只读状态</strong>而不是单例的可变状态。使用 Redux 时，在组件通过<em>dispatcher</em>发送操作后，只有纯函数<em>reducers</em>才能更新状态。</p><p>尽管使用这些工具并不会神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们预期的方式发生变化，因为组件无法直接更新状态。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://annachengdesu.github.io/tags/javascript/>Javascript</a></li></ul><nav class=paginav><a class=prev href=https://annachengdesu.github.io/post/patterns/observer-pattern/><span class=title>« Prev</span><br><span>05-Observer Pattern-设计模式学习-vanilla篇</span></a>
<a class=next href=https://annachengdesu.github.io/post/patterns/prototype/><span class=title>Next »</span><br><span>07-Prototype Pattern-设计模式学习-vanilla篇</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://annachengdesu.github.io/>Anna.me</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>